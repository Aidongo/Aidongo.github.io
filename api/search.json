[{"id":"799ea85b1d457160335b421a8e814a56","title":"VM虚拟机","content":"VM虚拟机挂起、重启后无法联网原因Ubuntu 默认网卡 ens33 在虚拟机启动时，没有自动启动 &#x3D;&gt; 设置的静态ip无法生效\n解决方案\n查看网卡托管是否启动 nmcli n \n\n开启托管 nmcli n on\n\n重启 systemctl restar NetworkManager 或者 reboot\n\n检查 ens33 网口是否自启动： ip addr\n\n\n如果ens33 下面有ip地址说明，网卡自启成功\n\n\n\n\t\t\n","slug":"虚拟机/Ubuntu","date":"2023-04-13T22:30:00.000Z","categories_index":"虚拟机","tags_index":"Ubuntu","author_index":"ARBIN"},{"id":"a37f6487303dd9ac4600a84c9410fc39","title":"Compiler Testing OpenJDK","content":"System Environment\n\n\nDistributor ID\nUbuntu\n\n\n\nDescription\nUbuntu 20.04.5 LTS\n\n\nRelease\n20.04\n\n\nCodename\nfocal\n\n\nDownload Source CodeOpenJDK11u-dev\nBuilding the OpenJDKOfficial Reference Document\n1. Run Configuresudo bash .&#x2F;configure -with-boot-jdk&#x3D;&#x2F;usr&#x2F;lib&#x2F;java&#x2F;jdk-11.0.17\n\nException (required package not pre-installed)\nconfigure: error: Could not find all X11 headers (shape.h Xrender.h Xrandr.h XTest.h Intrinsic.h).\n\nRun sudo apt-get install libXtst-devel libXt-devel libXrender-devel   ⇒  E: Unable to locate package\n\nSearch for the corresponding package name on the Ubuntu Package official website and download it one by one\n\nsudo apt-get install libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libxrandr-dev\n\n\n\nconfigure: error: Could not find cups!\n\nRun sudo apt-get install libcups2-dev\n\n\nconfigure: error: Could not find fontconfig!\n\nInstall required packages: sudo apt-get install libfontconfig1-dev\n\n\nconfigure: error: Could not find alsa!\n\nInstall required packages: sudo apt-get install libasound2-dev\n\n\n\n\n\n\n\n\n\n\n\n\nReference Blog\n2. Run Makesudo make all\nCompile JDK with Instrumentation (AFL)\nCompile the JDK to be fuzzed using afl-gcc\nCC&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;afl-gcc CXX&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;afl-g++ bash .&#x2F;configure --disable-warnings-as-errors\nmake all\n\n\n\nTest Javac\nafl-fuzz -i .&#x2F;fuzz-in -o .&#x2F;fuzz-out&#x2F;output03080022 -- &#x2F;home&#x2F;arbin0829&#x2F;Environment&#x2F;java&#x2F;jdk11u-dev-master&#x2F;build&#x2F;linux-x86_64-normal-server-release&#x2F;jdk&#x2F;bin&#x2F;javac @@\n\nPreparing the input corpusPreparing the input corpus is a crucial step in the fuzz testing process, as it directly affects the coverage and effectiveness of the testing. For this project, I will take the following steps to prepare the input corpus:\n1. Known valid input filesCollect Java program code from multiple open-source projects as input files, such as Apache Tomcat, Spring Framework, JMeter, etc. \n\n\n\n\n\n\n\n\n\nThese codes have undergone extensive testing and optimization and can be successfully compiled by the Java compiler.\n2. Invalid input filesManually write or use automated tools to generate some Java code that does not conform to Java compiler specifications or contains syntax errors.\n\n\n\n\n\n\n\n\n\nsuch as using undefined variables or syntax error code segments.\n3. Collect code that may cause the compiler to crash or behave abnormallyCollect some known malicious code or test cases from academic research papers or test suites. \n\n\n\n\n\n\n\n\n\nThese codes contain various abnormal behaviors, such as buffer overflow, infinite loops, etc.\n4. Generate input files automaticallyUse some tools to automatically generate Java code files, such as using Java code generators, random string generators, etc.\n\n\n\n\n\n\n\n\n\nThis can quickly generate a large number of input files to increase the coverage of testing.\n","slug":"Project/Compile Testing OpenJDK11u-dev","date":"2023-04-12T01:50:00.000Z","categories_index":"Project","tags_index":"Compiler Testing","author_index":"ARBIN"},{"id":"a82004346219b89210300085e2164ae5","title":"LeetCode 数组","content":"数组理论基础概念：数组是存放在连续内存空间上的相同类型数据的集合\n字符数组例子：\n\n\n\n数组下标都是从0开始的。\n数组内存空间的地址是连续的\n\n二维数组\n\n\n\n\n\n\n\n\n\n\n\nJava的二维数组在内存中不是 3*4 的连续地址空间，而是四条连续的地址空间组成\n\n\n704. 二分查找题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例 1:\n  输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9     \n输出: 4       \n解释: 9 出现在 nums 中并且下标为 4\n\n示例 2:\n  输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2     \n输出: -1        \n解释: 2 不存在 nums 中因此返回 -1\n\n提示：\n\n你可以假设 nums 中的所有元素是不重复的。\nn 将在 [1, 10000]之间。\nnums 的每个元素都将在 [-9999, 9999]之间。\n\n思路这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素。（二分法前提条件）\n\n若存在重复元素，使用二分查找法返回的元素下标可能不是唯一的\n在二分查找的过程中，保持不变量（循环不变量规则）\n在while寻找中每一次边界的处理都要坚持根据区间的定义来操作\n\n\n\n二分法：区间的定义一般为两种\n\n左闭右闭，[left, right]\n左闭右开，[left, right)\n\n✏️ 写法一（左闭右闭）定义 target 是在一个在左闭右闭的区间里，即 **[left, right]**，因此有如下两点：\n\nwhile (left &lt;&#x3D; right) ：使用 &lt;&#x3D;\n因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;\n\n\nif (nums[middle] &gt; target)\nright 要赋值为 (middle - 1)，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 (middle - 1)\n\n\n\n\n\n\n\n\n\n\n\n\n例如在数组：1,2,3,4,7,9,10中查找元素2：\n\n\n\n\nclass Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int left &#x3D; 0;\n        int right &#x3D; nums.length - 1;           &#x2F;&#x2F; 定义target在左闭右闭的区间里，[left, right]\n        &#x2F;&#x2F; 判断是否不存在\n        if(target &lt; nums[left] || target &gt; nums[right])\n            return -1;\n        while (left &lt;&#x3D; right) &#123;                &#x2F;&#x2F; 当left&#x3D;&#x3D;right，区间[left, right]依然有效，所以用 &lt;&#x3D;\n            int mid &#x3D; (right + left) &#x2F; 2;\n            if(nums[mid] &#x3D;&#x3D; target)\n                return mid;                   &#x2F;&#x2F; 数组中找到目标值，直接返回下标\n            else if (nums[mid] &lt; target)      \n                left &#x3D; mid + 1;               &#x2F;&#x2F; target 在右区间，所以[middle + 1, right]\n            else if (nums[mid] &gt; target)\n                right &#x3D; mid - 1;              &#x2F;&#x2F; target 在左区间，所以[left, middle - 1]\n        &#125;\n\t\t\t\t&#x2F;&#x2F; 未找到目标值\n        return -1;\n    &#125;\n&#125;\n\n\n✏️ 写法二：左闭右开\n\n定义 target 是在一个在左闭右开的区间里：[left, right)\n\nwhile (left &lt; right) ：使用 &lt;\n因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的\n\n\nif (nums[middle] &gt; target)\nright 更新为 middle：因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，\n即：下一个查询区间不会去比较nums[middle]\n\n\n\n\n\n\n\n\n\n\n\n\n例如在数组：1,2,3,4,7,9,10中查找元素2：\n\n\n\n\n代码示例\nclass Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int left &#x3D; 0;\n        int rifht &#x3D; nums.length;        &#x2F;&#x2F; 定义target在左闭右开的区间里，即：[left, right)\n        while(left &lt; rifht)&#123;            &#x2F;&#x2F; 因为left &#x3D;&#x3D; right的时候，在[left, right)是无效的空间，所以使用 &lt;\n            int mid &#x3D; (left + rifht) &#x2F; 2;\n            if(target &#x3D;&#x3D; nums[mid])     &#x2F;&#x2F; 数组中找到目标值，直接返回下标\n                return mid;\n            else if(target &lt; nums[mid])\n                rifht &#x3D; mid;            &#x2F;&#x2F; target 在左区间，在[left, middle)中\n            else if(target &gt; nums[mid])\n                left &#x3D; mid + 1;         &#x2F;&#x2F; target 在右区间，在[middle + 1, right)中\n        &#125;\n        &#x2F;&#x2F; 未找到目标值\n        return -1;\n    &#125;\n&#125;\n\n\n027. 移除元素题目给你一个数组 nums **和一个值 val，你需要 原地 移除所有数值等于 val **的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。\n\n示例 1：\n  输入：nums &#x3D; [3,2,2,3], val &#x3D; 3\n输出：2, nums &#x3D; [2,2]\n解释：函数应该返回新的长度2, 并且 nums中的前两个元素均为2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。\n\n示例 2：\n  输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2\n输出：5, nums &#x3D; [0,1,4,0,3]\n解释：函数应该返回新的长度5, 并且 nums 中的前五个元素为0,1,3,0,4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n提示：\n\n0 &lt;= nums.length &lt;= 100\n0 &lt;= nums[i] &lt;= 50\n0 &lt;= val &lt;= 100\n\n思路（快慢指针）双指针： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n定义快慢指针\n\n快指针：寻找新数组的元素\n慢指针：新数组下标的位置\n\nclass Solution &#123;\n    public int removeElement(int[] nums, int val) &#123;\n        &#x2F;&#x2F; 快慢指针\n        int slowIndex &#x3D; 0;\n        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.length; fastIndex++)&#123;\n            if(nums[fastIndex] !&#x3D; val)&#123;\n                nums[slowIndex] &#x3D; nums[fastIndex];\n                slowIndex ++;\n            &#125;\n        &#125;\n        return slowIndex;\n    &#125;\n&#125;\n\n\n977. 有序数组的平方题目给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n示例 1：\n  输入：nums &#x3D; [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n\n示例 2：\n  输入：nums &#x3D; [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n\n\n提示：\n\n1 &lt;= nums.length &lt;= 104\n104 &lt;= nums[i] &lt;= 104\nnums 已按 非递减顺序 排序\n\n思路数组其实是有序的， 只不过负数平方之后可能成为最大数了。\n那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。\n此时可以考虑双指针法了，i指向起始位置，j指向终止位置。\n定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置：\n\nA[i] * A[i] &lt; A[j] * A[j] ⇒ result[k--] = A[j] * A[j];\nA[i] * A[i] &gt;= A[j] * A[j] ⇒ result[k--] = A[i] * A[i];\n\n代码示例\nclass Solution &#123;\n    public int[] sortedSquares(int[] nums) &#123;\n        int left &#x3D; 0;\n        int right &#x3D; nums.length - 1;\n        int[] result &#x3D; new int[nums.length];\n        int index &#x3D; result.length - 1;\n        while(left &lt;&#x3D; right)&#123;\n            if(nums[left] * nums[left] &gt; nums[right] * nums[right])&#123;\n                &#x2F;&#x2F; 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置\n                result[index--] &#x3D; nums[left] * nums[left];\n                ++left;\n            &#125; else &#123;\n                result[index--] &#x3D; nums[right] * nums[right];\n                --right;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n\n209. 长度最小的子数组给定一个含有 n ****个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ****≥ target *的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。*如果不存在符合条件的子数组，返回 0 。\n\n示例 1：\n  输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组[4,3] 是该条件下的长度最小的子数组。\n\n\n示例 2：\n  输入：target &#x3D; 4, nums &#x3D; [1,4,4]\n输出：1\n\n\n示例 3：\n  输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]\n输出：0\n\n\n提示：\n\n1 &lt;= target &lt;= 109\n1 &lt;= nums.length &lt;= 105\n1 &lt;= nums[i] &lt;= 105\n\n思路（滑动窗口）在本题中实现滑动窗口，主要确定如下三点：\n\n窗口内是什么？\n窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n\n\n如何移动窗口的起始位置？\n窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。\n\n\n如何移动窗口的结束位置？\n窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n\n\n\n\n\n\n\n\n\n\n\n\n举例，s&#x3D;7， 数组是 2，3，1，2，4，3，来看一下查找的过程\n\n\n代码示例\nclass Solution &#123;\n    public int minSubArrayLen(int target, int[] nums) &#123;\n        int result &#x3D; Integer.MAX_VALUE;\n        int i &#x3D; 0; &#x2F;&#x2F; 滑动窗口的起始位置\n        int sum &#x3D; 0; &#x2F;&#x2F; 滑动窗口数值总和\n        int subLength &#x3D; 0; &#x2F;&#x2F; 滑动窗口的长度\n        for (int j &#x3D; 0; j &lt; nums.length; j++)&#123;\n            sum +&#x3D; nums[j];\n            &#x2F;&#x2F; 当终止位置j向后移动至窗口内数值总和 &gt;&#x3D; target时\n            while (sum &gt;&#x3D; target)&#123;          &#x2F;&#x2F; 使用while，移动起始位置i，并判断子序列是否符合条件\n                subLength &#x3D; (j - i + 1);    &#x2F;&#x2F; 获取子序列长度\n                result &#x3D; result &lt; subLength ? result : subLength;\n                sum -&#x3D; nums[i++];   &#x2F;&#x2F; 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result &#x3D;&#x3D; Integer.MAX_VALUE ? 0 : result;\n    &#125;\n&#125;\n\n\n时间复杂度：O(n)\n主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。\n\n\n空间复杂度：O(1)\n\n\n59.螺旋矩阵II题目给你一个正整数 n ，生成一个包含 1 到 $n^2$所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n示例 1：\n  \n  输入：n &#x3D; 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n\n\n示例 2：\n  输入：n &#x3D; 1\n输出：[[1]]\n\n\n提示：\n\n1 &lt;= n &lt;= 20\n\n思路模拟顺时针画矩阵的过程（坚持循环不变量原则）:\n\n填充上行从左到右\n填充右列从上到下\n填充下行从右到左\n填充左列从下到上\n\n左闭右开原则：\n\n\n代码示例\nclass Solution &#123;\n    public int[][] generateMatrix(int n) &#123;\n        int[][] res &#x3D; new int[n][n];\n        int start &#x3D; 0;&#x2F;&#x2F;定义每个圈的起始位置\n        int loop &#x3D; 0;       &#x2F;&#x2F; 每一个圈循环的次数\n        int count &#x3D; 1;      &#x2F;&#x2F; 定义填充数字，从1开始\n        int i,j;\n        while(loop++ &lt; n&#x2F;2)&#123;    &#x2F;&#x2F; 判断边界后，loop从1开始, loop也能作为控制的遍历长度\n\n            &#x2F;&#x2F; 下面开始的四个for就是模拟转了一圈\n            &#x2F;&#x2F; 模拟填充上行从左到右(左闭右开)\n            for(j &#x3D; start; j &lt; n - loop; j++)\n                res[start][j] &#x3D; count++;\n\n            &#x2F;&#x2F; 模拟填充右列从上到下(左闭右开)\n            for(i &#x3D; start; i &lt; n - loop; i++)\n                res[i][j] &#x3D; count++;\n\n            &#x2F;&#x2F; 模拟填充下行从右到左(左闭右开)\n            for(; j &gt;&#x3D; loop; j--)\n                res[i][j] &#x3D; count++;\n\n            &#x2F;&#x2F; 模拟填充左列从下到上(左闭右开)\n            for(; i &gt;&#x3D; loop; i--)\n                res[i][j] &#x3D; count++;\n\n            &#x2F;&#x2F; 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)\n            start++;\n        &#125;\n\n        &#x2F;&#x2F; 如果n为奇数的话，需要单独给矩阵最中间的位置赋值\n        if (n % 2 &#x3D;&#x3D; 1)\n            res[start][start] &#x3D; count;\n\n        return res;\n    &#125;\n&#125;","slug":"面试攻略/数组","date":"2023-04-04T01:37:00.000Z","categories_index":"LeetCode","tags_index":"数组","author_index":"ARBIN"},{"id":"8c6c59136f9c0c8c29b87ea646eed9d1","title":"操作系统","content":"一、进程、线程、协程1.进程【1】定义\n保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体\n这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统\n\n【2】特点\n操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位\n\n【3】进程常见状态\n就绪：进程已处于准备好运行的状态，即进程已分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行\n\n执行：进程已经获得CPU，程序正在执行状态。\n\n阻塞：正在执行的进程由于发生某事件（如I&#x2F;O请求、申请缓冲区失败等）暂时无法继续执行的状态。\n\n\n \n【4】进程间通信\n管道（pipe）：管道可用于具有亲缘关系的父子进程间的通信\n\n管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起\n可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中\n有名管道除了具有管道所具有的功能外，还允许无亲缘关系进程间的通信\n如在Linux中 who | wc -l 则通过管道的方法实现，C语言中利用fork()创建一个子进程\n\n\n\n\n\n\n\n\n\n\n无名管道：只能在亲缘关系（兄弟&#x2F;父子）间通信；半双工通讯；\n有名管道：可以实现没有亲缘关系的进程间通信；\n\n**信号（signal）**：信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动\n\n包括发出信号和捕获信号\nC语言中，信号的头文件在signal.h中定义\n信号的处理：signal() / sigaction()函数处理指定的信号，主要通过忽略和恢复其默认行为来工作\n发出信号：kill()和alarm()\n\n\n消息队列：消息队列是消息的链接表\n\n它克服了上两种通信方式中信号量有限的缺点\n具有写权限得进程可以按照一定得规则向消息队列中添加新信息\n对消息队列有读权限得进程则可以从消息队列中读取信息\n\n\n共享内存：可以说这是最有用的进程间通信方式\n\n它使得多个进程可以访问同一块内存空间\n不同进程可以及时看到对方进程中对共享内存中数据得更新\n这种方式需要依靠某种同步操作，如互斥锁和信号量等\n\n\n信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；\n\n套接字：这是一种更为一般得进程间通信机制\n\n可用于网络中不同机器之间的进程间通信，应用非常广泛。\n\n\n\n2.线程【1】定义\n线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位\n有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位\n\n【2】线程常见状态\n【3】线程类型\n用户级线程(user level thread)\n对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在\n在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源\n应用程序通常先在一个线程中运行，该线程被成为主线程\n在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程\n用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。\n\n\n内核级线程(kernel level thread)\n对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口\n内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成\n内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。\n\n\n\n【4】线程同步方式\n互斥量 Synchronized&#x2F;Lock\n采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限\n因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问\n\n\n信号量 Semphare\n允许同一时刻多个线程访问同一资源\n但是需要控制同一时刻访问此资源的最大线程数量\n\n\n事件(信号)，Wait&#x2F;Notify\n通过通知操作的方式来保持多线程同步\n还可以方便的实现多线程优先级的比较操作\n\n\n\n3. 进程和线程（区别）\n调度\n\n进程作为拥有资源的基本单位，具有自己独立的地址空间\n线程作为调度和分配的基本单位，\n\n\n并发性\n\n不仅进程之间可以并发执行\n同一个进程的多个线程之间也可并发执行；\n\n\n拥有资源\n\n进程是拥有资源的一个独立单位\n进程所维护的是程序所包含的资源（静态资源）如：地址空间、打开的文件句柄集、文件系统状态、信号处理handler等\n\n\n线程不拥有系统资源，但可以访问隶属于进程的资源\n线程所维护的运行相关的资源（动态资源）如：运行栈，调度相关的控制信息，待处理的信号集等；\n\n\n\n\n系统开销\n\n线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的\n这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出\n一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制\n每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢\n\n\n\n\n总结\n\n进程(process)与线程(thread)最大的区别是进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域。进程之间的通信需要通过进程间通信(Inter-process communication，IPC)。与之相对的，同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息。\n\n进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。\n\n\n\n\n4.协程【1】定义\n是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）\n性能得到了很大的提升，不会像线程切换那样消耗资源\n\n \n\n【2】特性\n一个多协程程序在同一时间只能运行一个协程\n正在执行的协程只会在其显式地要求挂起（suspend）时，它的执行才会暂停（无抢占、无并发）\n协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行\n\n【3】协程与多线程相比\n极高的执行效率\n子程序切换不是线程切换，而是由程序自身控制\n没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；\n\n\n不需要多线程的锁机制\n因为只有一个线程，也不存在同时写变量冲突\n在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多\n\n\n\n【4】参考例子（lua协程）\nresume\nyield\n\n5.进程调度【1】调度种类\n长程调度\n用于决定将外存上处于后备队列中的哪些作业调入内存，处于内存的就绪队列，准备执\n主要用来控制内存中进程的数量\n\n\n\n\n\n\n\n\n\n\n\n\n对照下图图来说就是新建进程的允许进入的两个箭头，说明进程已经进入到内存中来了。\n\n中程调度\n对应挂起状态进程的调度，是把内存中的进程挂起和被挂起的进程换进内存的过程\n\n\n\n\n\n\n\n\n\n\n\n\n对照下图来说就是换入换出的过程。\n\n短程调度\n按照某种策略和算法将处理机分配给一个处于就绪状态的进程，分为抢占式和非抢占式\n\n\n\n\n\n\n\n\n\n\n\n\n对应下图中的就绪状态到运行状态的箭头部分\n\n\n【2】调度方式\n抢占式\n操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式\n\n\n非抢占式\n分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程\n\n\n\n【3】进程调度算法\nFIFO&#x2F;FCFC（先来先服务）\n在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列\n调度的顺序就是任务到达就绪队列的顺序\n公平、简单(FIFO队列)、非抢占、不适合交互式\n算法简单，但效率低\n\n\n\n\n\n\n\n\n\n\n\n\n对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I&#x2F;O繁忙型作业。\n\n短进程优先算法(SJF, Shortest Job First)\n先按到达时间排序，若有多个进程的到达时间小于上一进程的结束时间，则将这多个进程按服务时间长短调度\n就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它\n使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度\n非抢占策略\n误区：不是直接将进程按服务时间的长短排序后顺序执行！！\n\n\n\n\n\n\n\n\n\n\n\n\n长作业不利，不能保证紧迫性作业（进程）被及时处理\n\n最短剩余时间优先（SRJF, Shortest Remaining Job First）\n针对最短进程优先增加了抢占机制的版本\n进程调度总是选择预期剩余时间最短的进程\n当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程\n\n\n\n\n\n\n\n\n\n\n\n\n进程剩余运行时间估计是很难确定的，并且存在长进程饥饿的危险\n\n时间片轮转算法（RR, Round-Robin）\n\n在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行\n抢占式算法\n设置一个时间片，按时间片来轮转调度（“轮叫”算法）\n优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；\n时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS\n\n\n优先权调度\n\n每个任务关联一个优先权，调度优先权最高的任务\n\n\n\n\n\n\n\n\n\n\n\n\n优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象\n\n多级反馈队列\n在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务\n可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”\n最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows\n\n\n\n\n\n\n\n\n\n\n\n\n注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。\n\n二、死锁1.定义\n如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件,那么该组进程就是死锁的。\n或者在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁\n通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态\n\n2.四个必要条件\n**互斥(Mutual exclusion)**：资源不能被共享，只能由一个进程使用\n**请求与保持(Hold and wait)**：已经得到资源的进程可以再次申请新的资源\n**非抢占(No pre-emption)**：已经分配的资源不能从相应的进程中被强制地剥夺\n**循环等待(Circular wait)**：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源\n\n3.如何预防死锁问题【1】破坏四个必要条件之一【2】有序资源分配法\n按某种规则系统中的所有资源统一编号（例如打印机为1,、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。\n\n\n\n\n\n\n\n\n\n\n例：采用有序资源分配法：R1的编号为1，R2的编号为2,；PA：申请次序应是：R1，R2；PB：申请次序应是：R1，R2；这样就破坏了环路条件，避免了死锁的发生。\n【3】银行家算法(最具代表性)\n检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求；\n申请者就可以很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生\n详细技术博文\n\n4.如何检测死锁\n可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源\n检测方法包括定时检测、效率低时检测、进程等待时检测等\n类似银行家算法就可以简单检测\n\n5.如何解除死锁【1】终止进程\n直接杀死进程，可使用kill()等方法\n\n【2】撤销进程，剥夺资源\n终止参与死锁的进程，收回它们占有的资源，从而解除死锁\n两种情况\n一次性撤消参与死锁的全部进程，剥夺全部资源；\n或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源\n一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；\n\n\n\n【3】进程回退策略\n让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁\n虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的\n\n\n三、内存管理1.连续分配管理\n\n\n\n\n\n\n\n\n定义：为一个用户程序分配一个连续的内存空间\n【1】固定分区\n大小相等：将内存划分为一个个大小相等的分区\n大小不相等：将内存划分为一个个大小相等的分区\n\n \n\n\n\n\n\n\n\n\n\n\n限制了活动进程的数目，若可用分区大小和进程大小非常不匹配，则内存的空间利用率非常低\n【2】动态分区\n首次适配思路\n\n按地址排序的空闲块列表（从头扫描内存）\n分配需要找到一个合适的分区\n重分配时需要检查，看是否自由分区能合并于相邻的空闲分区\n\n\n\n\n\n\n\n\n\n\n优点：简单；易于产生更大空闲块;\n缺点：外部碎片；不确定性。\n\n最佳适配思路\n 为了分配n字节，使用最小的比n大的可用空闲块\n\n按尺寸排列的空闲块列表\n分配需要寻找一个适合的分区\n重分配需要搜索及合并于相邻的空闲分区\n\n\n\n\n\n\n\n\n\n\n优点：当大部分分配是小尺寸时非常有效；比较简单;\n缺点：外部碎片，重分配慢，易产生很多没用的微小碎片\n\n下次适配\n\n从上一次放置的位置开始扫描内存\n选择下一个大小足够的可用块\n\n\n\n\n\n\n\n\n\n\n优点：每次分配是中等尺寸效果最好缺点：位于存储空间末尾的最大空闲存储块很快会被分裂成小碎片\n\n最差适配最佳适配思路相反。为了分配n字节，使用最大可用空闲块，尽可能保证空闲块是最大的\n\n按查村排列的空闲块列表\n分配很快\n重分配需要合并于相邻的空闲分区，调整空闲块列表\n\n\n\n\n\n\n\n\n\n\n优点：每次分配是中等尺寸效果最好缺点：重分配慢；外部碎片；易于破碎大的空闲块以至大分区无法被分配\n\n\n\n\n\n\n\n\n\n\n\n维护特别复杂，引入了压缩产生\n【3】伙伴系统\n结合了2的方幂个分配器和空闲缓冲区合并计技术的内存分配方案,\n基本思想： 内存被分成含有很多页面的大块, 每一块都是2个页面大小的方幂\n如果找不到想要的块, 一个大块会被分成两部分, 这两部分彼此就成为伙伴\n其中一半被用来分配, 而另一半则空闲\n这些块在以后分配的过程中会继续被二分直至产生一个所需大小的块\n当一个块被最终释放时, 其伙伴将被检测出来, 如果伙伴也空闲则合并两者\n\n\n\n\n\n2.非连续分配管理\n\n\n\n\n\n\n\n\n定义：允许一个程序使用的内存分布在离散或者说不相邻的内存中\n【1】分段\n逻辑地址&#x3D;s（段号）, o（段内偏移）\n\n段表&#x3D;s（段号），限制（段长），基址\n\n单地址实现方案\n\n\n \n\n\n段寄存器+地址寄存器实现方案\n\n首先判断逻辑地址的段号s是否超过段表寄存器中的段表长度，如果超过则会产生越界异常\n如果不超过则去段表中找到对应的段号（段表始值+段号）\n判断偏移o是否超过段长，不超过则找到对应的基址+偏移得到物理地址\n\n \n\n【2】分页\n页框：划分物理内存至固定大小的帧\n\n页：将进程划分为同等大小的多个小块\n\n物理地址的寻址方式:\n\n物理地址是通过逻辑地址和页表换算出来的\nf（帧号，F位，共2^F个帧），o（帧内偏移，S位，每帧 2^S字节）\n物理地址 &#x3D; 2^S^ * f + o\n\n\n逻辑地址的寻址方式：\n\n页内偏移的大小&#x3D;帧内偏移的大小\np（页号，P位，2^P个页），o（页内偏移，S位，每页有 2^S字节）\n逻辑地址&#x3D;2^S^ * p + o\n\n\n页表\n\n每个运行的程序都有一个页表。属于程序运行状态，会动态变化\nPTBR是页表基址寄存器\n页表是页号和一些标志位及帧号的映射\n\n \n\n页表缓存\n\nMMU（内存管理单元）中有一个TLB对于页表的缓存，一般存一页数据，是近期访问的页帧转换表项的缓存（这也是后序页面置换算法的参考点）\n\nkey-&gt;p；value-&gt;f\n\n注：p是页号，f是帧号，后序都用这两个字母表示\n\n如果TLB命中，物理页号可以很快被获取；如果TLB未命中，对应的表项被更新到TLB中。\n \n\n\n多级页表\n\n解决了时间的开销，再看看空间的代价\n\n由于逻辑地址空间很大，所以需要很大的页表，为了使页表所占的空间变小，所以可以使用多级页表。\n\n可以将页表中的页号细化，分为p1，p2\n\n每级页表都存储下一级页表的索引，n级页表一次类推，下面是二级页表的寻址过程：\n \n\n\n\n\n四、虚拟内存技术1.概述\n为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存\n程序的局部性原理：在程序执行过程中的一个较短时期，所有执行的指令地址和指令的操作地址分别局限于一定区域\n虚存技术的特征\n大的用户空间：通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际内存空间，实现二者分离\n部分交换：调入调出都是对部分虚拟地址空间进行\n不连续性：物理内存分配的不连续，虚拟地址空间分配不连续\n\n\n\n2.基本思路\n当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可以启动程序\n在运行的过程中，如果发现要运行的程序或要访问的数据不再内存，则向系统发出缺页中断请求，系统在处理这个中断请求时，将外存中响应的页面调入内存，是程序能够继续运行\n\n3.特征位\n页表 &#x3D; 逻辑页号 + 访问位 + 修改位 + 保护位 + 驻留位 + 物理页帧号\n\n驻留位：表示该页在内存还是外存\n\n保护位：允许对该页做何种类型的访问（只读，可读写，可执行等）\n\n修改位：表明此页是否被修改过。如果被修改过就会导致内存中和硬盘中的数据不一致，所以换入换出时需要保证数据的一致性。当系统回收物理页面时，根据此位来决定是否把它的内容写回外存。\n\n访问位：该页面是否被访问过，用于页面置换算法\n\n\n4.基本流程 \n\n5.常见置换算法【1】最佳置换算法（OPT）\n思路：把将来最长时间不需要的页面置换。\n\n\n\n\n\n\n\n\n\n该算法无法实现，但是会利用该算法作为参考，评价其他算法\n\n\n【2】先进先出（FIFO）\n思路：将内存中驻留时间最长的页面置换。其实就是维护一个队列，每次置换队头那页\n\n\n\n\n\n\n\n\n\n性能较差，调初的页面可能是经常要访问的页面，并且有Belady现象（类似于逆向优化的现，增加内存的大小，很难降低缺页率），FIFO很少单独使用\n\n\n【3】最近最久未使用（LRU）\n思路：选择最久未使用的那个页面置换。是对最优页面置换算法的近似，根据过去推测未来。\n\n操作系统具体可以用以下方法实现：\n\n维护一个链表，刚使用的放表头，最久未使用的作为尾节点。每次访问内存时，找到相应的页面，把它移到表头。发生缺页中断后，淘汰链表末尾的页面。\n设置一个活动栈，访问页面时，将次页号压入栈顶，将栈内相同的页号都删掉。每次总是置换栈底元素。\n\n\n\n\n\n\n\n\n\n\nLRU性能较好，但需要寄存器和栈的硬件支持，LRU是堆栈类的算法\n理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。\n\n\n【4】时钟（CLOCK）\n利用页表中的访问位（Access Bit），初始化为0，每次访问后都会置为1，操作系统又定期将其变为0。\n\n思路：当发生缺页中断时，若当前访问位&#x3D;&#x3D;1则置0，指针向下走，直到遇到访问位&#x3D;&#x3D;0的页面就进行置换；若当前访问位&#x3D;&#x3D;0则置换该页，然后指针指向下一个地址。在这个过程中，指针类似于时钟往一个方向走。\n\n\n","slug":"Computer Basis/操作系统知识点","date":"2023-04-04T01:04:00.000Z","categories_index":"计算机基础","tags_index":"操作系统,面试知识点","author_index":"ARBIN"},{"id":"293c17b4d2a4292133cc4d1ffd7f8725","title":"计算机网络","content":"相关博客\n一、体系结构\nOSI 七层模型\nTCP&#x2F;IP 四层模型\nTCP&#x2F;IP 五层模型\n\n​\t\n\n1.物理层\n数据传输单位： 比特（bit）\n作用： 激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性\n设备： 中继器、集线器\n\n2.数据链路层\n数据传输单位：帧（frame）\n作用：在 物理层 提供的服务基础向上 网络层 提供服务，将源自网络层的数据可靠地传输到相邻节点得目标机网络层\n封装成帧：将上层传下来得IP数据报加上首部和尾部（包括许多控制信息）\n透明传输\n差错检测\n\n\n设备：网桥、交换机\n协议：VLAN、MAC、PPP、以太网\n\n3.网络层\n数据传输单位：IP数据报\n作用：实现两个主机系统之间的数据透明传送\n路径选择\n路由\n逻辑寻址\n\n\n协议\nIP 协议\nICMP 协议\nARP 协议 （MAC）\n\n\n设备：路由器\n\n4.运输层（Socket）\n数据传输单位：TCP报文 &#x2F;  UDP报文\n作用：负责向**两台主机进程**之间的通信提供通用的数据传输服务\n\n\n\n\n\n\n\n\n\n\n网络层只是根据网络地址将源节点发出的数据包传送到目的节点，而传输层则负责将数据可靠地传送到相应的端口。\n\n协议\nTCP（传输控制协议）：提供**面向连接的，可靠的**数据传输服务\nUDP（用户数据协议）：提供**无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性**）\n\n\n设备：网关\n\n5.会话层、表示层【1】会话层\n作用：管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话\n利用在数据中插入校验点来实现数据的同步\n\n【2】表示层\n作用：对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解\n数据转换：数据的加密、压缩、格式转换\n\n6. 应用层（最靠近用户的OSI层）\n作用：通过利用对应进程间的交互来完成特定网络作用\n\n\n\n\n\n\n\n\n\n\n应用层协议当以的是**应用进程**间的通信和交互的规则\n\n协议\n\nFTP（文件传送协议）\n\nTelnet（远程登陆协议）\n\nDNS协议（作为可以将域名和IP地址相互映射的一个分布式数据库，IP与域名的映射）\n\nSMTP（邮件传送协议）\n\nPOP3（邮局协议）\n\nHTTP协议（超文本传输协议）\n设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法\n\n\n\n\n\n二、IP1.IP地址划分网络号（net-id）：标识主机或路由器所连到的网\n主机号（host-id）：标志该主机（或路由器）\n\nA类地址以0开头：第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255\nB类地址以10开头：前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255\nC类地址以110开头：前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255\nD类地址以1110开头：地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）\nE类地址以1111开头：地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用\n\n****\n2.子网划分\n作用：在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号 \n \n\n子网掩码\n\n定义：标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位\n计算：通过 IP地址 与 子网掩码 与运算得到网络地址\n相关博文：https://www.cnblogs.com/inception6-lxc/p/9152691.html\n\n\n三、协议1.ARP&#x2F;RARP【1】ARP的（地址解析协议）\n定义：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议\n（通过网络层使用的IP地址解析得出链路层使用的硬件地址）\n\nARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等\n\n工作流程\n\n每个主机在自己的ARP缓冲区建立一个ARP列表，以表示 &#x3D;&#x3D;IP地址&#x3D;&#x3D; 和 &#x3D;&#x3D;MAC地址&#x3D;&#x3D;\n当主机A欲向本局域网的主机B发送IP数据报时，首先在ARP高速缓冲区中查看有无主机B的IP地址\n如有：即可通过对应IP地址查出硬件地址，将硬件地址写入MAC帧，通过局域网将MAC帧发送此硬件地址\n如无：ARP进程在本局域网广播发送一个ARP请求分组（源主机IP地址，源主机MAC地址，目的主机IP地址）\n\n\n当本网络所有主机收到该ARP时，检查ARP请求分组中的目的IP地址是否为本机\n若不是：忽略该分组\n若是：首先将源主机IP和MAC地址取出存入ARP列表（添加或覆盖），并将本机MAC地址写入ARP响应分组中\n\n\n若源主机一直没收到ARP响应分组则表示ARP查询失败\n\n\n\n【2】RARP\n定义：功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址\n\n比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。\n\n\n工作流程\n\n给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址\n本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址\n如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；\n如果不存在，RARP服务器对此不做任何的响应\n源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败\n\n\n\n\n2.TCP&#x2F;UDP【1】TCP（传输控制协议，Transmission Control Protocl）\n定义：是一种面向连接的、可靠的、基于字节流的传输层通信协议\n\n应用场景：当对网络通讯质量有要求的时候，整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用\n\n\n\n协议\n定义\n端口号\n\n\n\nFTP\n文件传输协议\n21\n\n\nTelnet\n用于远程登陆的端口用户可以以自己的身份远程连接到计算机上可提供基于DOS模式下的通信服务\n23\n\n\nSMTP\n邮件传送协议，用于发送邮件\n25\n\n\nPOP3\n和SMTP对应，POP3用于接收邮件\n110\n\n\nHTTP\nWeb服务器传输超文本到本地浏览器的传送协议\n80\n\n\n\n报文标志位\n\nURG: 标识紧急指针是否有效\nACK: 标识确认序号是否有效\nPSH: 用来提示接收端应用程序立刻将数据从tcp缓冲区读走\nRST: 要求重新建立连接. 我们把含有RST标识的报文称为复位报文段\nSYN: 请求建立连接. 我们把含有SYN标识的报文称为同步报文段\nFIN: 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为结束报文段\n\n\n\n【2】UDP(用户数据报协议，User Datagram Protocol）\n定义: 支持无连接的传输协议, 功能即为在IP的数据报服务之上增加了最基本的服务复用和分用以及差错检测\n应用场景: 当强调传输性能而不是传输的完整性时， 要求网络通讯速度能尽量的快。如：QQ语音 QQ视频等。\n\n\n\n\n协议\n定义\n端口号\n\n\n\nDNS\n域名解析服务，将域名地址转换为IP地址\n53\n\n\nSNMP\n简单网络管理协议\n161\n\n\nTFTP\n简单文件传输协议\n69\n\n\n【3】TCP 和 UDP 区别\n\n\n\nUDP\nTCP\n\n\n\n是否连接\n无连接\n面向连接\n\n\n是否可靠\n不可靠传输，不使用流量控制和拥塞控制\n可靠传输，使用流量控制和拥塞控制\n\n\n连接对象个数\n支持一对一，一对多，多对一和多对多交互通信\n只能是一对一通信\n\n\n传输方式\n面向报文\n面向字节流\n\n\n首部开销\n首部开销小，仅8字节\n首部最小20字节，最大60字节\n\n\n适用场景\n适用于实时应用（IP电话、视频会议、直播等）\n适用于要求可靠传输的应用，例如文件传输\n\n\n\n3.TCP流量控制&#x2F;拥塞控制【1】流量控制\n手段：滑动窗口实现流量控制\n目的：控制发送方发送速率，保证接收方来得及接收。\n基本实现\n接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率\n将窗口字段设置为 0，则发送方不能发送数据。\n\n\n\n【2】拥塞控制\n拥塞：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏\n作用：防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载\n前提：网络能够承受现有的网络负荷\n全局性过程\n涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。\n流量控制：是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。\n\n\n\nTCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复\n在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。\n\n拥塞窗口(cwnd)：发送方需要维持的状态变量\n拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化\n发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。\n\n\n慢开始 \n思路：由小到大逐渐增大拥塞窗口数值，cwnd &#x3D; 1\n每经过一个传输轮次，cwnd *&#x3D; 2\n设置慢开始门限状态变量ssthresh\ncwnd &lt; ssthresh ，使用慢开始算法\ncwnd &gt; ssthresh ，停止使用慢开始算法改用拥塞避免算法\ncwnd &#x3D; ssthresh，既可使用慢开始也可使用拥塞避免\n\n\n\n\n拥塞避免 \n思路：让拥塞窗口cwnd缓慢增大\n每经过一个传输轮次，cwnd +&#x3D; 1\n\n\n快重传与快恢复：快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法\n能快速恢复丢失的数据包\n有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认\n快重传：如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段\n快恢复：当执行完快重传时，执行快恢复算法\n慢开始门限 ssthresh &#x3D; 当前拥塞窗口 cwnd / 2\n新拥塞窗口 cwnd &#x3D; 慢开始门限 ssthresh\n开始执行拥塞避免算法，使阻塞窗口缓慢地先行增大\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n当网络出现拥塞（重传定时器超时）\n\nsshthres &#x3D; max（cwnd&#x2F;2 , 2）\n\ncwnd &#x3D; 1\n\n执行慢开始方法\n目的：迅速减少主机发送到网络中的分组数，使得发生拥塞得路由器有足够得时间把队列中积压的分组处理完毕\n\n\n \n\n4.ARQ协议\n自动重传请求（Automatic Repeat-reQuest，ARQ）\nOSI模型中数据链路层和传输层的错误纠正协议之一\n通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输\n如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送\nARQ包括停止等待ARQ协议和连续ARQ协议。\n\n\n\n【1】停止等待ARQ协议\n作用：实现可靠传输\n基本原理：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。\n\n\n\n\n\n\n\n\n\n\n在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。\n\n优缺点：\n优点： 简单\n缺点： 信道利用率低，等待时间长\n\n\n\n(1)无差错情况:\n\n发送方发送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送。\n\n(2)出现差错情况（超时重传）:\n\n只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）\n因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ \n在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认\n\n(3)确认丢失和确认迟到\n\n确认丢失 ：确认消息在传输过程丢失\n当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失\n而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：\n丢弃这个重复的M1消息，不向上层交付。\n向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。\n\n\n\n\n确认迟到 ：确认消息在传输过程中迟到\nA发送M1消息，B收到并发送确认\n在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）\n此时A收到了B第二次发送的确认消息，接着发送其他数据\n过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息），处理如下：\nA收到重复的确认后，直接丢弃\nB收到重复的M1后，也直接丢弃重复的M1。\n\n\n\n\n\n【2】连续ARQ协议\n基本原理\n\n发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认\n接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n\n\n优缺点：\n\n优点： 信道利用率高，容易实现，即使确认丢失，也不必重传\n缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息\n比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息\n\n\n\n\n\n\n5.HTTP（超文本传输协议）\n定义：基于TCP&#x2F;IP通信协议来传递数据的一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型；默认端口80\n工作原理：HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端\n\n【1】HTTP 请求&#x2F;响应的步骤\n客户端连接到Web服务器\n\n一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接\n例如：http://www.oakcms.cn\n\n\n发送HTTP请求\n\n通过TCP套接字，客户端向Web服务器发送一个文本的请求报文\n一个请求报文由请求行、请求头部、空行和请求数据4部分组成。\n\n\n服务器接受请求并返回HTTP响应\n\nWeb服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取\n一个响应由状态行、响应头部、空行和响应数据4部分组成。\n\n\n释放连接TCP连接\n\n若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接\n若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求\n\n\n客户端浏览器解析HTML内容\n\n客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码\n然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集\n客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n\n\n\nHTTP常见状态码\n2xx：（成功）成功处理了请求的状态代码\n\n200 (成功) ：服务器已成功处理了请求\n\n\n3xx：（重定向）要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n\n304 (未修改) ：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容\n\n\n4xx：(客户端请求错误) 请求有语法错误或请求无法实现\n400 (错误请求) 服务器不理解请求的语法\n403 (禁止) 服务器拒绝请求\n404 (未找到) 服务器找不到请求的网页。\n\n\n5xx：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错\n500 (服务器内部错误)： 服务器遇到错误，无法完成请求\n501 (尚未实施)： 服务器不具备完成请求的功能 例如，服务器无法识别请求方法时可能会返回此代码\n502 (错误网关)： 服务器作为网关或代理，从上游服务器收到无效响应\n503 (服务不可用)： 服务器目前无法使用(由于超载或停机维护)；通常，这只是暂时状态\n504 (网关超时)： 服务器作为网关或代理，但是没有及时从上游服务器收到请求\n505 (HTTP 版本不受支持)： 服务器不支持请求中所用的 HTTP 协议版本。\n\n\n\n常见HTTP首部字段\n相关博文\n\n\n6.HTTPS\n定义：一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL&#x2F;TLS建立全信道，加密数据包\n主要目的：提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性\n\n工作原理\n\n客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接\nWeb服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端\n客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级\n客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站\nWeb服务器利用自己的私钥解密出会话密钥\nWeb服务器利用会话密钥加密与客户端之间的通信\n\n \n\n相关博文\nHTTPS工作原理\n较好理解的一个链接\n\n\n\n7.SSL协议\n定义：位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层\nSSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯\n\n\n由两层组成\n&#x3D;&#x3D;SSL记录协议:&#x3D;&#x3D;建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能\n&#x3D;&#x3D;SSL握手协议:&#x3D;&#x3D;建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等\n\n\nSSL握手\n客户端发送 Client Hello 报文开始 SSL通信。\n报文中包含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。\n服务器以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。\n服务器发送 Certificate 报文。报文中包含公开密钥证书。\n最后服务器发送 Server Hello Done 报文通知客户端。\n客户端以 Client Key Exchange 报文作为回应。\n报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。\n客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。\n客户端发送 Finished 报文。\n服务器发送 Change Cipher Spec 报文。\n服务器发送 Finished 报文\n\n\n\n\n四、面试题1.TCP协议如何保证可靠传输\n应用数据被分割成 TCP 认为最适合发送的数据块。\nTCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。\n校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。\nTCP 的接收端会丢弃重复的数据。\n流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）\n拥塞控制： 当网络拥塞时，减少数据的发送。\nARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。\n超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。\n\n\n2.TCP连接最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器\n\nTCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；\n\nTCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文\n\n报文首部中的同步位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，TCP客户端进程进入 SYN-SENT（同步已发送状态）状态\n\nTCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号\n\n\n\nTCP服务器收到请求报文后，如果同意连接，则发出确认报文\n\n确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y\n此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。\n\n\nTCP客户进程收到确认后，还要向服务器给出确认\n\n确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1\nTCP连接建立，客户端进入ESTABLISHED（已建立连接）状态\nTCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号\n\n\n当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。\n\n\n问：为什么TCP客户端最后还要发送一次确认呢？   答：防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误\n\n\n\n\n\n\n\n\n\n如果使用的是两次握手建立连接\n假设有这样一种场景\n\n客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文\n\n此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的。但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要错误和资源的浪费\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n\n\n\n3.TCP连接释放\n\n\n\n\n\n\n\n\n数据传输完毕后，双方都可释放连接\n最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭\n\n客户端进程发出连接释放报文，并且停止发送数据\n释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1）\n客户端进入FIN-WAIT-1（终止等待1）状态\nTCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n\n\n服务器收到连接释放报文，发出确认报文\nACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v\n服务端就进入了CLOSE-WAIT（关闭等待）状态\nTCP服务器通知高层的应用进程，客户端向服务器的方向就释放了\n这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受\n这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n\n\n客户端收到服务器的确认请求\n客户端就进入FIN-WAIT-2（终止等待2）状态\n等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n\n\n服务器将最后的数据发送完毕后，就向客户端发送连接释放报文\nFIN&#x3D;1，ACK&#x3D;1，ack&#x3D;u+1\n由于在半关闭状态，服务器很可能又发送了一些数据\n假定此时的序列号为seq&#x3D;w\n服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n\n\n客户端收到服务器的连接释放报文后，必须发出确认\nACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1\n客户端就进入了TIME-WAIT（时间等待）状态\n注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态\n\n\n服务器只要收到了客户端发出的确认，立即进入CLOSED状态\n撤销TCB后，就结束了这次的TCP连接\n服务器结束TCP连接的时间要比客户端早一些。\n\n\n\n \n\n【1】问：为什么客户端最后还要等待2MSL？\n\n\n\n\n\n\n\n\nMSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。\n答：保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失\n\n站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。\n\nTIME_WAIT至少需要持续2MSL时长，这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失\n\n\n【2】问：为什么建立连接是三次握手，关闭连接确是四次挥手呢？答：\n\n建立连接时：服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端\n关闭连接时：服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，己方ACK和FIN一般都会分开发送，从而导致多了一次\n\n【3】问：如果已经建立了连接，但是客户端突然出现故障了怎么办？答：TCP还设有一个保活计时器\n\n客户端如果出现故障，服务器不能一直等下去，白白浪费资源\n服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次\n若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n\n\n4.DNS解析\n浏览器将会检查缓存中有没有这个域名对应的解析过的IP地址\n\n如果有该解析过程将会结束\n浏览器缓存域名也是有限制的，包括缓存的时间、大小，可以通过TTL属性来设置。\n\n\n如果用户的浏览器中缓存中没有\n\n操作系统会先检查自己本地的hosts文件是否有这个网址映射关系\n如果有，就先调用这个IP地址映射，完成域名解析。\n\n\n如果hosts里没有这个域名的映射\n\n查找本地DNS解析器缓存，是否有这个网址映射关系\n如果有，直接返回，完成域名解析。\n\n\n如果hosts与本地DNS解析器缓存都没有相应的网址映射关系\n\n首先会找TCP&#x2F;ip参数中设置的首选DNS服务器（本地DNS服务器）\n此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性\n\n\n如果要查询的域名，不由本地DNS服务器区域解析\n\n但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性\n\n\n如果本地DNS服务器本地区域文件与缓存解析都失效\n\n则根据本地DNS服务器的设置（是否设置转发器）进行查询\n如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP\n本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器\n这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址给本地DNS服务器\n当本地DNS服务器收到这个地址后，就会找域名域服务器，重复上面的动作，进行查询，直至找到域名对应的主机。\n\n\n如果用的是转发模式\n\n此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析\n上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环\n不管是本地DNS服务器用是是转发，还是迭代，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机\n\n\n\n5.在浏览器中输入www.baidu.com后执行的全部过程\n应用层：客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48\n通过这个IP地址找到客户端到服务器的路径\n客户端浏览器发起一个HTTP会话到220.161.27.48\n通过TCP进行封装数据包，输入到网络层。\n\n\n\n\nDNS解析过程\n\n\n\n\nHTTP请求与响应\n\n\n\n\n运输层：在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口\n\n如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口\n然后使用IP层（网络层）的IP地址查找目的端\n\n\n网络层：通过查找路由表确定如何到达目的服务器\n\n期间可能经过多个路由器，这些都是由路由器来完成的工作，OSPF协议\n\n\n\n\n\n\n链路层：客户端的链路层，通过链路层发送到路由器\n通过邻居协议查找给定IP地址的MAC地址\n然后发送ARP请求查找目的地址\n如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了\n然后发送IP数据包到达服务器的地址。\n\n\n\n  \n\n\n6.HTTP与HTTPS的区别相关博文：https://blog.csdn.net/xiaoming100001/article/details/81109617\n\n\n\n\n\n\n\n\n\nHTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。\nHTTPS和HTTP的区别主要如下：\nhttps协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。\nhttp是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。\nhttp和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\nhttp的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\n\nHTTPS优缺点优点\n使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\nHTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。\nHTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。\n谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。\n\n缺点\nHTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；\nHTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；\nSSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。\nSSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。\nHTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。\n\n\n7.常见的HTTP方法\nGET： 从服务器获得资源\nPOST： 客户端向服务器提交资源\nPUT： 修改服务器相关资源  (已经很少用)\nDELETE： 删除服务器相关资源  (已经很少用)\n\nGET方法与POST方法的区别,什么时候应该使用GET什么时候应该使用POST？\nGET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符\nPOST：一般用于修改服务器上的资源，对所发送的信息数量没有限制\nGET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n\n\n\n\n\n\n\n\n\n\n小结：对于信息的获取一般使用get,在以下情况下最好使用post请求:\n\n向服务器发送大量数据（因为post没有发送数据的数量限制） \n无法使用缓存文件（会更新服务器上的文件）\n发送包含未知字符的用户输入时(亲身经历过GET的坑,泪目)\n\n\n8.HTTP1.0和HTTP1.1的区别【1】缓存处理\nHTTP1.0：主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准\nHTTP1.1：则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n\n【2】带宽优化及网络连接的使用\nHTTP1.0：存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能\nHTTP1.1：在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n【3】错误通知的管理\n在HTTP1.1中新增了24个错误状态响应码\n如409（Conflict）表示请求的资源与资源的当前状态发生冲突\n410（Gone）表示服务器上的某个资源被永久性的删除\n\n\n\n【4】Host头处理（但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址）\n\nHTTP1.0：认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）\nHTTP1.1：请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）\n\n【5】长连接\nHTTP 1.1：支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理\n在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，\n+HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\n\n","slug":"Computer Basis/计算机网络知识点","date":"2023-04-03T16:35:00.000Z","categories_index":"计算机基础","tags_index":"面试知识点,计算机网络","author_index":"ARBIN"},{"id":"1bf705b8c909d15201118f0311dec3fe","title":"SSql Language","content":"SSql Language: Simplified SQL and Data Analysis Language 📊Group Member\nRuibin Zhu , Chenhui Liu\nProject OverviewSSql is a simplified SQL and data analysis Domain Specific Language (DSL) designed to simplify tasks such as database querying, data analysis, data cleaning, and generating statistical charts. With a concise syntax defined using Xtext, users can easily create and execute complex queries without needing to understand the intricacies of underlying database technologies.\nSSql supports the following types of statements:\n\nConnectStatement: Connect to a database\nQueryStatement: Execute queries\nStatisticStatement: Generate statistical charts\nVariableDeclaration: Define query variables\nCheckStatement: Check specific database objects\n\nThe following sections will provide instructions on how to set up the environment for using SSql, how to run the project, and how to use the SSql language for query and data analysis tasks.\nEnvironment SetupThe environment required for running this project is Eclipse IDE. Additional modelling and plugin support are required. For more information on the required dependencies, refer to this page (King’s internal credentials required).\nPlease note that Java 11 or higher is required to run this project.\nSome of the above folder projects are intended to live in the base Eclipse environment, while others are created for Runtime Eclipse. The following list displays this separation:\nXtext Project\n\nuk.ac.kcl.mmd.group39. SSql \nuk.ac.kcl.mmd.group39. SSql.ide \nuk.ac.kcl.mmd.group39. SSql.tests \nuk.ac.kcl.mmd.group39. SSql.ui \nuk.ac.kcl.mmd.group39. SSql.ui.tests\n\nRuntime Eclipse:\n\nTestSSql (providing sample .SSql files with corresponding generated code) \nuk.ac.kcl.mmd.group39.ssql.library (A collection of utility classes and methods supporting the SSql language) \nuk.ac.kcl.mmd.group39.SSql.xpect (tests for the language)\n\nSample DatabaseMicrosoft Northwind Trader DatabaseThe project aim to port northwind database from MS SQL 2005 to MySQL,Oracle,PostGreSQL,Sqlite,VistaDB with Tables,Views,Triggers,User Defined Function,Stored Procedure that simulation similary into all databases that include some functions that are available to only advanced databases with simulation and schema readers.\nRunning the ProjectXtext Project\nAfter installing the required dependencies, clone this repository into an Eclipse workspace.\nNavigate to uk.ac.kcl.mmd.group39.SSql and open the SSql.xtext file.\nRight-click anywhere in the file and choose Run As &gt; Generate Xtext Artifacts.\nWait for the artifacts to generate, and then launch Runtime Eclipse by right-clicking on the uk.ac.kcl.mmd.group39.SSql project and choosing Run As &gt; Eclipse Application.\n\nRun Time - Eclipse Xtext Environment\nIn Runtime Eclipse import the trhee projects from above \nTestSSq\nuk.ac.kcl.mmd.group39.SSql.xpect\nuk.ac.kcl.mmd.group39.ssql.library\n\n\nBuild Path with library project \nRight-click TestSSql project choose Buil Path &gt; Configure Build Path... &gt; Projects &gt; Add , then choose the uk.ac.kcl.mmd.group39.ssql.library\n\n\nImport dependency packages\nImport Right-click TestSSql/lib project choose Buil Path &gt; Configure Build Path... &gt; Libraries &gt; Add JARs , then add the following jars:\njcommon-1.0.24.jar\njfreechart-1.5.3.jar\nmysql-connector-j-8.0.32.jar\n\n\n\n\nSample can already be found in the src folder of the TestSsql.SSql\nTo create a new SSql , right-click on the src folder of TestSSql project and choose New &gt; File.\nThe file extension for SSql is .SSql.\n\n\nWrite the contract code and hit Ctrl + S to save it. This action will automatically create a .java file and place it in the src-gen folder. This file will contain the generated Java code.\n\nUsing SSql LanguageTo use the SSql language, start by creating a .SSql file. In this file, you can write SSql queries and data analysis tasks. Here’s a simple example:\n1. Connect StatementEstablish a connection to a MySQL database using the CONNECT statement with a JDBC connection string, username, and password.\nBefore all operations, you must first use this statement to establish a connection to the database\nCONNECT(&#39;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;northwind&#39;,&#39;username&#39;,&#39;password&#39;)\n\n2. Query StatementRetrieve all records from the orders table using the SELECT statement:\n&#x2F;&#x2F; Query Statement\nSELECT * FROM orders\n\n3. Statistic StatementGenerate a bar chart with a title, X and Y labels, and data based on a query:\nsqlCopy codeSTATS CHART BAR &#123;\n\tTitle: &quot;ShipVia&quot;;\n\tXLabel: &quot;Count&quot;;\n\tYLabel: &quot;Y&quot;;\n\tData: (SELECT orders.ShipVia, SUM(orderdetails.UnitPrice * orderdetails.Quantity * (1 - orderdetails.Discount)) FROM orders JOIN orderdetails ON orders.OrderID &#x3D; orderdetails.OrderID  BY orders.ShipVia);\n&#125;\n\n4. VariableDeclarationStore the result of a query in a variable for reuse:\nVAR data4ShipVia &#x3D; (SELECT orders.ShipVia, SUM(orderdetails.UnitPrice * orderdetails.Quantity * (1 - orderdetails.Discount)) FROM orders JOIN orderdetails ON orders.OrderID &#x3D; orderdetails.OrderID  BY orders.ShipVia)\n\n5. Statistic Statement with VariableGenerate bar and line charts using the data stored in a variable:\nsqlCopy codeSTATS CHART BAR &#123;\n\tTitle: &quot;ShipVia&quot;;\n\tXLabel: &quot;Count&quot;;\n\tYLabel: &quot;Y&quot;;\n\tData: (data4ShipVia);\n&#125;\n\nSTATS CHART LINE &#123;\n\tTitle: &quot;ShipVia&quot;;\n\tXLabel: &quot;Count&quot;;\n\tYLabel: &quot;Y&quot;;\n\tData: (data4ShipVia);\n&#125;\n\n\n\n6. Data CleaningPerform data cleaning operations on the products table:\n\nFind duplicates:\n\nsqlCopy codeSTATS CLEAN &#123;\n\tTable: &quot;products&quot;\n\tColumn: &quot;UnitPrice&quot;\n\tFunction: FIND_DUPLICATES\n&#125;\n\n\nFind missing values:\n\nsqlCopy codeSTATS CLEAN &#123;\n\tTable: &quot;products&quot;\n\tColumn: &quot;UnitPrice&quot;\n\tFunction: FIND_MISSING_VALUES\n&#125;\n\n\nFind missing values and fill with the mean:\n\nsqlCopy codeSTATS CLEAN &#123;\n\tTable: &quot;products&quot;\n\tColumn: &quot;UnitPrice&quot;\n\tFunction: FIND_MISSING_VALUES\n\tSolution: FILL_IN_MEAN\n&#125;\n\n7. Check StatementsPerform various checks on customers and products:\n\nCheck a customer’s billing information:\n\nsqlCopy codeCHECK Customer &#123;\n\tID: &quot;ALFKI&quot;\n\tType: BillAll\n&#125;\n\nCHECK Customer &#123;\n\tID: &quot;ALFKI&quot;\n\tType: Bill\n\tDate: 1994-07-15 to 1995-07-15\n&#125;\n\n\nCheck product information and sales:\n\nsqlCopy codeCHECK Product &#123;\n\tID: &quot;3&quot;\n\tType: ProductInfo\n&#125;\n\nCHECK Product &#123;\n\tType: TopSale\n\tDate: 1996-07-15 to 2000-07-15\n\tLimit: 1\n&#125;\n\nCHECK Product &#123;\n\tCategoryName: &quot;Beverages&quot;\n\tType: GroupCategory\n&#125;\n\nThese use cases provide a solid understanding of the various capabilities of the SSql language and how to use them in practice.\nIn this example, we first connect to the database, then query all data from the employees table, and generate a bar chart displaying the salaries of employees.\nTo execute the SSql code, save the .ssql file. This will automatically generate the corresponding Java or other target language code, which you can copy into the appropriate project to run.\nFuture ImprovementsWhile SSql already offers a wide range of features to simplify data analysis and visualization tasks, there is potential for future improvements to make the language even more powerful and user-friendly. Some possible enhancements include:\n\nMore Visualization Options: Expand the variety of available chart types (e.g., scatter plots, bubble charts, heatmaps) and customization options (e.g., colors, fonts, legend placement) to provide users with more flexibility in data visualization.\nSupport for Additional Database Systems: Broaden the range of supported databases, such as PostgreSQL, Oracle, and MongoDB, to make SSql more versatile for different projects and environments.\nEnhanced Data Cleaning Features: Implement more advanced data cleaning functions, such as outlier detection and handling, data normalization, and pattern recognition.\nImproved Error Handling and Debugging: Provide more detailed error messages and debugging tools to help users identify and resolve issues more efficiently.\nIntegration with Data Analysis Libraries: Integrate popular data analysis libraries (e.g., pandas, NumPy) to further expand SSql’s analytical capabilities.\nUser Interface Improvements: Develop a dedicated graphical user interface (GUI) or plugins for popular IDEs to streamline the SSql development process.\nSupport for Real-Time Data Analysis: Enable real-time data analysis and visualization by incorporating support for streaming data sources and dynamic chart updates.\nPerformance Optimization: Optimize the performance of SSql to handle large datasets and complex queries more efficiently.\n\nBy incorporating these improvements, SSql can continue to evolve and cater to the growing needs of users in the field of data analysis and visualization.\n","slug":"Kings/SSql Introduction","date":"2023-04-03T00:47:00.000Z","categories_index":"King's College London","tags_index":"Coursework","author_index":"ARBIN"},{"id":"da7db9db2fae252fd6be2449c29d4fe0","title":"One Drive使用向导","content":"One Drive 使用教程Step 1. 登录账户\n\nStep 2. 选择One Drive文件夹\n所选择的文件夹将作为One Drive共享文件夹同步至One Drive云盘当中。\n\n可以从其他设备访问One Drive文件夹的文件，但文件仍可以存储在本地Mac设备中\n\n\n具体步骤如下图所示\n\n选择One Drive 文件夹\n\n\n\n\n下图所选择的是Material &gt; Fayeeff\n\n\n\n\n选择成功后界面\n\n\n\n\nOne Drive共享文件夹会创建为 Material &gt; Fayeeff &gt; One Drive 目录\n也可以通过 Finder &gt; OneDrive 中访问OneDrive共享文件夹，在此文件夹下的文件都将同步至共享云盘\n\n\n\n\nStep 3. 上传文件示例\n移动所需上传文件至One Drive当中，如 钢琴基础.pdf\n \n\n文件将上传至One Drive云端中\n \n\n可在浏览器中查看：在线查看\n\n\n \n","slug":"One Drive/One Drive使用教程","date":"2023-04-02T22:44:00.000Z","categories_index":"Guide","tags_index":"One Drive","author_index":"ARBIN"}]