{"title":"操作系统","uid":"8c6c59136f9c0c8c29b87ea646eed9d1","slug":"Computer Basis/操作系统知识点","date":"2023-04-04T01:04:00.000Z","updated":"2023-04-04T01:16:04.045Z","comments":true,"path":"api/articles/Computer Basis/操作系统知识点.json","keywords":null,"cover":"https://s2.loli.net/2023/04/04/xcKeEI3hwAW5JZN.jpg","content":"<h1 id=\"一、进程、线程、协程\"><a href=\"#一、进程、线程、协程\" class=\"headerlink\" title=\"一、进程、线程、协程\"></a>一、进程、线程、协程</h1><h2 id=\"1-进程\"><a href=\"#1-进程\" class=\"headerlink\" title=\"1.进程\"></a>1.进程</h2><h3 id=\"【1】定义\"><a href=\"#【1】定义\" class=\"headerlink\" title=\"【1】定义\"></a><strong>【1】定义</strong></h3><ul>\n<li>保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体</li>\n<li>这个内存体<strong>有自己独立的地址空间，有自己的堆</strong>，上级挂靠单位是操作系统</li>\n</ul>\n<h3 id=\"【2】特点\"><a href=\"#【2】特点\" class=\"headerlink\" title=\"【2】特点\"></a><strong>【2】特点</strong></h3><ul>\n<li>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位</li>\n</ul>\n<h3 id=\"【3】进程常见状态\"><a href=\"#【3】进程常见状态\" class=\"headerlink\" title=\"【3】进程常见状态\"></a><strong>【3】进程常见状态</strong></h3><ul>\n<li><p><strong>就绪：</strong>进程已处于准备好运行的状态，即进程已分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行</p>\n</li>\n<li><p><strong>执行：</strong>进程已经获得CPU，程序正在执行状态。</p>\n</li>\n<li><p><strong>阻塞：</strong>正在执行的进程由于发生某事件（如I&#x2F;O请求、申请缓冲区失败等）暂时无法继续执行的状态。</p>\n</li>\n</ul>\n<p> <img src=\"https://s2.loli.net/2023/04/04/9geGIMqUSzNhRWs.jpg\" alt=\"img\"></p>\n<h3 id=\"【4】进程间通信\"><a href=\"#【4】进程间通信\" class=\"headerlink\" title=\"【4】进程间通信\"></a><strong>【4】进程间通信</strong></h3><ul>\n<li><p><strong><a href=\"https://blog.csdn.net/yishizuofei/article/details/78301414\">管道（pipe）</a>：</strong>管道可用于具有亲缘关系的<strong>父子进程间</strong>的通信</p>\n<ul>\n<li>管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起</li>\n<li>可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中</li>\n<li>有名管道除了具有管道所具有的功能外，还允许无亲缘关系进程间的通信</li>\n<li>如在Linux中 <code>who | wc -l</code> 则通过管道的方法实现，C语言中利用fork()创建一个子进程</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>无名管道：只能在亲缘关系（兄弟&#x2F;父子）间通信；半双工通讯；</p>\n<p>有名管道：可以实现没有亲缘关系的进程间通信；</p></blockquote>\n</li>\n<li><p>**<a href=\"https://www.cnblogs.com/52php/p/5813867.html\">信号（signal）</a>**：信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动</p>\n<ul>\n<li>包括发出信号和捕获信号</li>\n<li>C语言中，信号的头文件在<code>signal.h</code>中定义</li>\n<li>信号的处理：<code>signal() / sigaction()</code>函数处理指定的信号，主要通过忽略和恢复其默认行为来工作</li>\n<li>发出信号：<code>kill()</code>和<code>alarm()</code></li>\n</ul>\n</li>\n<li><p><strong>消息队列：</strong>消息队列是消息的链接表</p>\n<ul>\n<li>它克服了上两种通信方式中信号量有限的缺点</li>\n<li>具有写权限得进程可以按照一定得规则向消息队列中添加新信息</li>\n<li>对消息队列有读权限得进程则可以从消息队列中读取信息</li>\n</ul>\n</li>\n<li><p><strong>共享内存：</strong>可以说这是最有用的进程间通信方式</p>\n<ul>\n<li>它使得多个进程可以访问同一块内存空间</li>\n<li>不同进程可以及时看到对方进程中对共享内存中数据得更新</li>\n<li>这种方式需要依靠某种同步操作，如互斥锁和信号量等</li>\n</ul>\n</li>\n<li><p><strong>信号量：</strong>主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p>\n</li>\n<li><p><strong>套接字：</strong>这是一种更为一般得进程间通信机制</p>\n<ul>\n<li>可用于网络中不同机器之间的进程间通信，应用非常广泛。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-线程\"><a href=\"#2-线程\" class=\"headerlink\" title=\"2.线程\"></a>2.线程</h2><h3 id=\"【1】定义-1\"><a href=\"#【1】定义-1\" class=\"headerlink\" title=\"【1】定义\"></a>【1】定义</h3><ul>\n<li><strong>线程</strong>是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位</li>\n<li>有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位</li>\n</ul>\n<h3 id=\"【2】线程常见状态\"><a href=\"#【2】线程常见状态\" class=\"headerlink\" title=\"【2】线程常见状态\"></a>【2】线程常见状态</h3><p><img src=\"https://s2.loli.net/2023/04/04/iLrBsHx5pedoPjm.jpg\" alt=\"线程常见状态\"></p>\n<h3 id=\"【3】线程类型\"><a href=\"#【3】线程类型\" class=\"headerlink\" title=\"【3】线程类型\"></a>【3】线程类型</h3><ul>\n<li><strong>用户级线程(user level thread)</strong><ul>\n<li>对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在</li>\n<li>在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源</li>\n<li>应用程序通常先在一个线程中运行，该线程被成为主线程</li>\n<li>在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程</li>\n<li><strong>用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。</strong></li>\n</ul>\n</li>\n<li><strong>内核级线程(kernel level thread)</strong><ul>\n<li>对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口</li>\n<li>内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成</li>\n<li>内核级线程的好处是，<strong>内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"【4】线程同步方式\"><a href=\"#【4】线程同步方式\" class=\"headerlink\" title=\"【4】线程同步方式\"></a>【4】线程同步方式</h3><ul>\n<li><strong>互斥量 Synchronized&#x2F;Lock</strong><ul>\n<li>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限</li>\n<li>因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li>\n</ul>\n</li>\n<li><strong>信号量 Semphare</strong><ul>\n<li>允许同一时刻多个线程访问同一资源</li>\n<li>但是需要控制同一时刻访问此资源的最大线程数量</li>\n</ul>\n</li>\n<li><strong>事件(信号)，Wait&#x2F;Notify</strong><ul>\n<li>通过通知操作的方式来保持多线程同步</li>\n<li>还可以方便的实现多线程优先级的比较操作</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-进程和线程（区别）\"><a href=\"#3-进程和线程（区别）\" class=\"headerlink\" title=\"3. 进程和线程（区别）\"></a>3. 进程和线程（区别）</h2><ul>\n<li><p><strong>调度</strong></p>\n<ul>\n<li>进程作为拥有资源的基本单位，具有自己独立的地址空间</li>\n<li>线程作为调度和分配的基本单位，</li>\n</ul>\n</li>\n<li><p><strong>并发性</strong></p>\n<ul>\n<li>不仅进程之间可以并发执行</li>\n<li>同一个进程的多个线程之间也可并发执行；</li>\n</ul>\n</li>\n<li><p><strong>拥有资源</strong></p>\n<ul>\n<li>进程是拥有资源的一个独立单位<ul>\n<li>进程所维护的是程序所包含的资源（静态资源）如：地址空间、打开的文件句柄集、文件系统状态、信号处理handler等</li>\n</ul>\n</li>\n<li>线程不拥有系统资源，但可以访问隶属于进程的资源<ul>\n<li>线程所维护的运行相关的资源（动态资源）如：运行栈，调度相关的控制信息，待处理的信号集等；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>系统开销</strong></p>\n<ul>\n<li>线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的</li>\n<li>这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出</li>\n<li>一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制<ul>\n<li>每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>总结</strong></p>\n<ul>\n<li><p>进程(process)与线程(thread)最大的区别是<strong>进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域</strong>。进程之间的通信需要通过进程间通信(Inter-process communication，IPC)。与之相对的，<strong>同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息</strong>。</p>\n</li>\n<li><p><strong>进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。</strong>通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。<strong>相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-协程\"><a href=\"#4-协程\" class=\"headerlink\" title=\"4.协程\"></a>4.协程</h2><h3 id=\"【1】定义-2\"><a href=\"#【1】定义-2\" class=\"headerlink\" title=\"【1】定义\"></a>【1】定义</h3><ul>\n<li>是一种比线程更加轻量级的存在，<strong>协程不是被操作系统内核所管理</strong>，而<strong>完全是由程序所控制（也就是在用户态执行）</strong></li>\n<li>性能得到了很大的提升，不会像线程切换那样消耗资源</li>\n</ul>\n <img src=\"https://s2.loli.net/2023/04/04/F1uvqZKrMfTXOGm.jpg\" alt=\"在这里插入图片描述\" style=\"zoom:50%;\" />\n\n<h3 id=\"【2】特性\"><a href=\"#【2】特性\" class=\"headerlink\" title=\"【2】特性\"></a>【2】特性</h3><ul>\n<li>一个多协程程序在同一时间只能运行一个协程</li>\n<li>正在执行的协程只会在其显式地要求<strong>挂起（suspend）</strong>时，它的执行才会<strong>暂停（无抢占、无并发）</strong></li>\n<li>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行</li>\n</ul>\n<h3 id=\"【3】协程与多线程相比\"><a href=\"#【3】协程与多线程相比\" class=\"headerlink\" title=\"【3】协程与多线程相比\"></a>【3】协程与多线程相比</h3><ul>\n<li><strong>极高的执行效率</strong><ul>\n<li><strong>子程序切换不是线程切换，而是由程序自身控制</strong></li>\n<li><strong>没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显；</li>\n</ul>\n</li>\n<li><strong>不需要多线程的锁机制</strong><ul>\n<li>因为只有一个线程，也不存在同时写变量冲突</li>\n<li><strong>在协程中控制共享资源不加锁</strong>，只需要判断状态就好了，所以执行效率比多线程高很多</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"【4】参考例子（lua协程）\"><a href=\"#【4】参考例子（lua协程）\" class=\"headerlink\" title=\"【4】参考例子（lua协程）\"></a>【4】参考例子（lua协程）</h3><ul>\n<li>resume</li>\n<li>yield</li>\n</ul>\n<h2 id=\"5-进程调度\"><a href=\"#5-进程调度\" class=\"headerlink\" title=\"5.进程调度\"></a>5.进程调度</h2><h3 id=\"【1】调度种类\"><a href=\"#【1】调度种类\" class=\"headerlink\" title=\"【1】调度种类\"></a>【1】调度种类</h3><ul>\n<li><strong>长程调度</strong><ul>\n<li>用于决定将外存上处于后备队列中的哪些作业调入内存，处于内存的就绪队列，准备执</li>\n<li>主要用来控制内存中进程的数量</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对照下图图来说就是新建进程的<strong>允许进入</strong>的两个箭头，说明进程已经进入到内存中来了。</p></blockquote>\n<ul>\n<li><strong>中程调度</strong><ul>\n<li>对应挂起状态进程的调度，是把内存中的进程挂起和被挂起的进程换进内存的过程</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对照下图来说就是<strong>换入换出</strong>的过程。</p></blockquote>\n<ul>\n<li><strong>短程调度</strong><ul>\n<li>按照某种策略和算法将处理机分配给一个处于就绪状态的进程，分为抢占式和非抢占式</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对应下图中的<strong>就绪状态</strong>到<strong>运行状态</strong>的箭头部分</p></blockquote>\n<img src=\"https://s2.loli.net/2023/04/04/R2YuwryE51ZDKGt.jpg\" alt=\"在这里插入图片描述\" style=\"zoom: 50%;\" />\n\n<h3 id=\"【2】调度方式\"><a href=\"#【2】调度方式\" class=\"headerlink\" title=\"【2】调度方式\"></a>【2】调度方式</h3><ul>\n<li><strong>抢占式</strong><ul>\n<li>操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式</li>\n</ul>\n</li>\n<li><strong>非抢占式</strong><ul>\n<li>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"【3】进程调度算法\"><a href=\"#【3】进程调度算法\" class=\"headerlink\" title=\"【3】进程调度算法\"></a>【3】进程调度算法</h3><ul>\n<li><strong>FIFO&#x2F;FCFC（先来先服务）</strong><ul>\n<li>在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列</li>\n<li>调度的顺序就是任务到达就绪队列的顺序</li>\n<li>公平、简单(FIFO队列)、<strong>非抢占</strong>、不适合交互式</li>\n<li>算法简单，但效率低</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I&#x2F;O繁忙型作业。</p></blockquote>\n<ul>\n<li><strong>短进程优先算法(SJF, Shortest Job First)</strong><ul>\n<li>先按到达时间排序，若有多个进程的到达时间小于上一进程的结束时间，则将这多个进程按服务时间长短调度</li>\n<li>就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它</li>\n<li>使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度</li>\n<li><strong>非抢占策略</strong></li>\n<li><code>误区：</code>不是直接将进程按服务时间的长短排序后顺序执行！！</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>长作业不利，不能保证紧迫性作业（进程）被及时处理</p></blockquote>\n<ul>\n<li><strong>最短剩余时间优先（SRJF, Shortest Remaining Job First）</strong><ul>\n<li>针对最短进程优先<strong>增加了抢占机制</strong>的版本</li>\n<li>进程调度总是选择预期<strong>剩余时间最短</strong>的进程</li>\n<li>当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>进程剩余运行时间估计是很难确定的，并且存在长进程饥饿的危险</p></blockquote>\n<ul>\n<li><p><strong>时间片轮转算法（RR, Round-Robin）</strong></p>\n<ul>\n<li>在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行</li>\n<li><strong>抢占式算法</strong></li>\n<li>设置一个时间片，按时间片来轮转调度（“轮叫”算法）</li>\n<li>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</li>\n<li>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS</li>\n</ul>\n</li>\n<li><p><strong>优先权调度</strong></p>\n<ul>\n<li>每个任务关联一个优先权，调度优先权最高的任务</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象</p></blockquote>\n<ul>\n<li><strong>多级反馈队列</strong><ul>\n<li>在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务</li>\n<li>可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”</li>\n<li>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</p></blockquote>\n<hr>\n<h1 id=\"二、死锁\"><a href=\"#二、死锁\" class=\"headerlink\" title=\"二、死锁\"></a>二、死锁</h1><h2 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h2><ul>\n<li>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件,那么该组进程就是死锁的。</li>\n<li>或者在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁</li>\n<li>通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态</li>\n</ul>\n<h2 id=\"2-四个必要条件\"><a href=\"#2-四个必要条件\" class=\"headerlink\" title=\"2.四个必要条件\"></a>2.四个必要条件</h2><ul>\n<li>**互斥(Mutual exclusion)**：资源不能被共享，只能由一个进程使用</li>\n<li>**请求与保持(Hold and wait)**：已经得到资源的进程可以再次申请新的资源</li>\n<li>**非抢占(No pre-emption)**：已经分配的资源不能从相应的进程中被强制地剥夺</li>\n<li>**循环等待(Circular wait)**：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源</li>\n</ul>\n<h2 id=\"3-如何预防死锁问题\"><a href=\"#3-如何预防死锁问题\" class=\"headerlink\" title=\"3.如何预防死锁问题\"></a>3.如何预防死锁问题</h2><h3 id=\"【1】破坏四个必要条件之一\"><a href=\"#【1】破坏四个必要条件之一\" class=\"headerlink\" title=\"【1】破坏四个必要条件之一\"></a>【1】破坏四个必要条件之一</h3><h3 id=\"【2】有序资源分配法\"><a href=\"#【2】有序资源分配法\" class=\"headerlink\" title=\"【2】有序资源分配法\"></a>【2】有序资源分配法</h3><ul>\n<li>按某种规则系统中的所有资源统一编号（例如打印机为1,、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>例：采用有序资源分配法：R1的编号为1，R2的编号为2,；PA：申请次序应是：R1，R2；PB：申请次序应是：R1，R2；这样就破坏了环路条件，避免了死锁的发生。</p></blockquote>\n<h3 id=\"【3】银行家算法-最具代表性\"><a href=\"#【3】银行家算法-最具代表性\" class=\"headerlink\" title=\"【3】银行家算法(最具代表性)\"></a>【3】银行家算法<code>(最具代表性)</code></h3><ul>\n<li>检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求；</li>\n<li>申请者就可以很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生</li>\n<li><a href=\"https://blog.csdn.net/weixin_43886592/article/details/107582347\">详细技术博文</a></li>\n</ul>\n<h2 id=\"4-如何检测死锁\"><a href=\"#4-如何检测死锁\" class=\"headerlink\" title=\"4.如何检测死锁\"></a>4.如何检测死锁</h2><ul>\n<li>可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源</li>\n<li>检测方法包括定时检测、效率低时检测、进程等待时检测等</li>\n<li>类似银行家算法就可以简单检测</li>\n</ul>\n<h2 id=\"5-如何解除死锁\"><a href=\"#5-如何解除死锁\" class=\"headerlink\" title=\"5.如何解除死锁\"></a>5.如何解除死锁</h2><h3 id=\"【1】终止进程\"><a href=\"#【1】终止进程\" class=\"headerlink\" title=\"【1】终止进程\"></a>【1】终止进程</h3><ul>\n<li>直接杀死进程，可使用kill()等方法</li>\n</ul>\n<h3 id=\"【2】撤销进程，剥夺资源\"><a href=\"#【2】撤销进程，剥夺资源\" class=\"headerlink\" title=\"【2】撤销进程，剥夺资源\"></a>【2】撤销进程，剥夺资源</h3><ul>\n<li>终止参与死锁的进程，收回它们占有的资源，从而解除死锁</li>\n<li>两种情况<ul>\n<li>一次性撤消参与死锁的全部进程，剥夺全部资源；</li>\n<li>或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源</li>\n<li>一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"【3】进程回退策略\"><a href=\"#【3】进程回退策略\" class=\"headerlink\" title=\"【3】进程回退策略\"></a>【3】进程回退策略</h3><ul>\n<li>让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁</li>\n<li>虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的</li>\n</ul>\n<hr>\n<h1 id=\"三、内存管理\"><a href=\"#三、内存管理\" class=\"headerlink\" title=\"三、内存管理\"></a>三、内存管理</h1><h2 id=\"1-连续分配管理\"><a href=\"#1-连续分配管理\" class=\"headerlink\" title=\"1.连续分配管理\"></a>1.连续分配管理</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>定义：</strong>为一个用户程序分配一个连续的内存空间</p></blockquote>\n<h3 id=\"【1】固定分区\"><a href=\"#【1】固定分区\" class=\"headerlink\" title=\"【1】固定分区\"></a>【1】固定分区</h3><ul>\n<li><strong>大小相等：</strong>将内存划分为一个个大小相等的分区</li>\n<li><strong>大小不相等：</strong>将内存划分为一个个大小相等的分区</li>\n</ul>\n <img src=\"https://s2.loli.net/2023/04/04/GE7c81HdezmnjFW.png\" alt=\"image-20210801154231316\" style=\"zoom: 25%;\" />\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>限制了活动进程的数目，若可用分区大小和进程大小非常不匹配，则内存的空间利用率非常低</strong></p></blockquote>\n<h3 id=\"【2】动态分区\"><a href=\"#【2】动态分区\" class=\"headerlink\" title=\"【2】动态分区\"></a>【2】动态分区</h3><ul>\n<li><p><strong>首次适配思路</strong></p>\n<ul>\n<li>按地址排序的<strong>空闲块列表</strong>（从头扫描内存）</li>\n<li>分配需要找到一个合适的分区</li>\n<li>重分配时需要检查，看是否自由分区能合并于相邻的空闲分区</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>优点：</strong>简单；易于产生更大空闲块;</p>\n<p><strong>缺点：</strong>外部碎片；不确定性。</p></blockquote>\n</li>\n<li><p><strong>最佳适配思路</strong></p>\n<p> 为了分配n字节，使用<strong>最小的比n大</strong>的可用空闲块</p>\n<ul>\n<li>按尺寸排列的空闲块列表</li>\n<li>分配需要寻找一个适合的分区</li>\n<li>重分配需要搜索及合并于相邻的空闲分区</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>优点：</strong>当大部分分配是小尺寸时非常有效；比较简单;</p>\n<p><strong>缺点：</strong>外部碎片，重分配慢，易产生很多没用的微小碎片</p></blockquote>\n</li>\n<li><p><strong>下次适配</strong></p>\n<ul>\n<li>从上一次放置的位置开始扫描内存</li>\n<li>选择下一个大小足够的可用块</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>优点：每次分配是中等尺寸效果最好<br>缺点：位于存储空间末尾的最大空闲存储块很快会被分裂成小碎片</p></blockquote>\n</li>\n<li><p><strong>最差适配</strong><br>最佳适配思路相反。为了分配n字节，使用最大可用空闲块，尽可能保证空闲块是最大的</p>\n<ol>\n<li>按查村排列的空闲块列表</li>\n<li>分配很快</li>\n<li>重分配需要合并于相邻的空闲分区，调整空闲块列表</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>优点：每次分配是中等尺寸效果最好<br>缺点：重分配慢；外部碎片；易于破碎大的空闲块以至大分区无法被分配</p></blockquote>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>维护特别复杂，引入了压缩产生</strong></p></blockquote>\n<h3 id=\"【3】伙伴系统\"><a href=\"#【3】伙伴系统\" class=\"headerlink\" title=\"【3】伙伴系统\"></a>【3】伙伴系统</h3><ul>\n<li>结合了2的方幂个分配器和空闲缓冲区合并计技术的内存分配方案,</li>\n<li><strong>基本思想：</strong> 内存被分成含有很多页面的大块, 每一块都是2个页面大小的方幂<ul>\n<li>如果找不到想要的块, 一个大块会被分成两部分, 这两部分彼此就成为伙伴</li>\n<li>其中一半被用来分配, 而另一半则空闲</li>\n<li>这些块在以后分配的过程中会继续被二分直至产生一个所需大小的块</li>\n<li>当一个块被最终释放时, 其伙伴将被检测出来, 如果伙伴也空闲则合并两者</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://s2.loli.net/2023/04/04/al1VBxncJYg6tLe.png\" alt=\"image-20210801155859576\" style=\"zoom: 33%;\" />\n\n<h2 id=\"2-非连续分配管理\"><a href=\"#2-非连续分配管理\" class=\"headerlink\" title=\"2.非连续分配管理\"></a>2.非连续分配管理</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>定义：</strong>允许一个程序使用的内存分布在离散或者说不相邻的内存中</p></blockquote>\n<h3 id=\"【1】分段\"><a href=\"#【1】分段\" class=\"headerlink\" title=\"【1】分段\"></a>【1】分段</h3><ul>\n<li><p><strong>逻辑地址&#x3D;s（段号）, o（段内偏移）</strong></p>\n</li>\n<li><p>段表&#x3D;s（段号），限制（段长），基址</p>\n</li>\n<li><p><strong>单地址实现方案</strong></p>\n</li>\n</ul>\n <img src=\"https://s2.loli.net/2023/04/04/aNEX8ZBjgvioye4.png\" alt=\"image-20210801165543842\" style=\"zoom:33%;\" />\n\n<ul>\n<li><p><strong>段寄存器+地址寄存器实现方案</strong></p>\n<ol>\n<li>首先判断逻辑地址的<strong>段号s</strong>是否超过段表寄存器中的段表长度，如果超过则会产生越界异常</li>\n<li>如果不超过则去<strong>段表</strong>中找到对应的<strong>段号（段表始值+段号）</strong></li>\n<li>判断<strong>偏移o</strong>是否超过段长，不超过则找到对应的基址+偏移得到物理地址</li>\n</ol>\n <img src=\"https://s2.loli.net/2023/04/04/z23LTr1n9ADKMHP.jpg\" alt=\"img\" style=\"zoom: 50%;\" /></li>\n</ul>\n<h3 id=\"【2】分页\"><a href=\"#【2】分页\" class=\"headerlink\" title=\"【2】分页\"></a>【2】分页</h3><ul>\n<li><p><strong>页框：</strong>划分物理内存至固定大小的帧</p>\n</li>\n<li><p><strong>页：</strong>将进程划分为同等大小的多个小块</p>\n</li>\n<li><p><strong>物理地址</strong>的寻址方式:</p>\n<ul>\n<li>物理地址是通过逻辑地址和页表换算出来的</li>\n<li>f（帧号，F位，共2^F个帧），o（帧内偏移，S位，每帧 2^S字节）</li>\n<li>物理地址 &#x3D; 2^S^ * f + o</li>\n</ul>\n</li>\n<li><p><strong>逻辑地址</strong>的寻址方式：</p>\n<ul>\n<li>页内偏移的大小&#x3D;帧内偏移的大小</li>\n<li>p（页号，P位，2^P个页），o（页内偏移，S位，每页有 2^S字节）</li>\n<li>逻辑地址&#x3D;2^S^ * p + o</li>\n</ul>\n</li>\n<li><p><strong>页表</strong></p>\n<ul>\n<li>每个运行的程序都有一个页表。属于程序运行状态，会动态变化</li>\n<li>PTBR是页表基址寄存器</li>\n<li>页表是页号和一些标志位及帧号的映射</li>\n</ul>\n <img src=\"https://s2.loli.net/2023/04/04/6jtOlGmFH5ukMKI.jpg\" alt=\"img\" style=\"zoom: 50%;\" />\n</li>\n<li><p><strong>页表缓存</strong></p>\n<ul>\n<li><p>MMU（内存管理单元）中有一个TLB对于页表的缓存，一般存一页数据，是近期访问的页帧转换表项的缓存（这也是后序页面置换算法的参考点）</p>\n</li>\n<li><p>key-&gt;p；value-&gt;f</p>\n</li>\n<li><p>注：p是页号，f是帧号，后序都用这两个字母表示</p>\n</li>\n<li><p>如果TLB命中，物理页号可以很快被获取；如果TLB未命中，对应的表项被更新到TLB中。</p>\n <img src=\"https://s2.loli.net/2023/04/04/5MWLzUZsGYbR3Io.jpg\" alt=\"img\" style=\"zoom: 50%;\" /></li>\n</ul>\n</li>\n<li><p><strong>多级页表</strong></p>\n<ul>\n<li><p>解决了时间的开销，再看看空间的代价</p>\n</li>\n<li><p>由于逻辑地址空间很大，所以需要很大的页表，为了使页表所占的空间变小，所以可以使用多级页表。</p>\n</li>\n<li><p>可以将页表中的页号细化，分为p1，p2</p>\n</li>\n<li><p>每级页表都存储下一级页表的索引，n级页表一次类推，下面是二级页表的寻址过程：</p>\n <img src=\"https://s2.loli.net/2023/04/04/jbvS1Xl3F8EUrnB.jpg\" alt=\"img\" style=\"zoom: 50%;\" /></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"四、虚拟内存技术\"><a href=\"#四、虚拟内存技术\" class=\"headerlink\" title=\"四、虚拟内存技术\"></a>四、<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\">虚拟内存技术</a></h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h2><ul>\n<li><strong>为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</strong></li>\n<li><strong>程序的局部性原理</strong>：在程序执行过程中的一个较短时期，所有执行的指令地址和指令的操作地址分别局限于一定区域</li>\n<li><strong>虚存技术的特征</strong><ul>\n<li><strong>大的用户空间：</strong>通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际内存空间，实现二者分离</li>\n<li><strong>部分交换：</strong>调入调出都是对部分虚拟地址空间进行</li>\n<li><strong>不连续性：</strong>物理内存分配的不连续，虚拟地址空间分配不连续</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-基本思路\"><a href=\"#2-基本思路\" class=\"headerlink\" title=\"2.基本思路\"></a>2.基本思路</h2><ul>\n<li>当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可以启动程序</li>\n<li>在运行的过程中，如果发现要运行的程序或要访问的数据不再内存，则向系统发出缺页中断请求，系统在处理这个中断请求时，将外存中响应的页面调入内存，是程序能够继续运行</li>\n</ul>\n<h2 id=\"3-特征位\"><a href=\"#3-特征位\" class=\"headerlink\" title=\"3.特征位\"></a>3.特征位</h2><ul>\n<li><p><strong>页表 &#x3D; 逻辑页号 + 访问位 + 修改位 + 保护位 + 驻留位 + 物理页帧号</strong></p>\n</li>\n<li><p><strong>驻留位：</strong>表示该页在内存还是外存</p>\n</li>\n<li><p><strong>保护位：</strong>允许对该页做何种类型的访问（只读，可读写，可执行等）</p>\n</li>\n<li><p><strong>修改位：</strong>表明此页是否被修改过。如果被修改过就会导致内存中和硬盘中的数据不一致，所以换入换出时需要保证数据的一致性。当系统回收物理页面时，根据此位来决定是否把它的内容写回外存。</p>\n</li>\n<li><p><strong>访问位：</strong>该页面是否被访问过，用于页面置换算法</p>\n</li>\n</ul>\n<h2 id=\"4-基本流程\"><a href=\"#4-基本流程\" class=\"headerlink\" title=\"4.基本流程\"></a>4.基本流程</h2> <img src=\"https://s2.loli.net/2023/04/04/vK7Fo5mUHr19ejb.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<h2 id=\"5-常见置换算法\"><a href=\"#5-常见置换算法\" class=\"headerlink\" title=\"5.常见置换算法\"></a>5.常见置换算法</h2><h3 id=\"【1】最佳置换算法（OPT）\"><a href=\"#【1】最佳置换算法（OPT）\" class=\"headerlink\" title=\"【1】最佳置换算法（OPT）\"></a>【1】最佳置换算法（OPT）</h3><ul>\n<li><p><strong>思路：</strong>把将来最长时间不需要的页面置换。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>该算法无法实现，但是会利用该算法作为参考，评价其他算法</p></blockquote>\n</li>\n</ul>\n<h3 id=\"【2】先进先出（FIFO）\"><a href=\"#【2】先进先出（FIFO）\" class=\"headerlink\" title=\"【2】先进先出（FIFO）\"></a>【2】先进先出（FIFO）</h3><ul>\n<li><p><strong>思路：</strong>将内存中驻留时间最长的页面置换。其实就是维护一个队列，每次置换队头那页</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>性能较差，调初的页面可能是经常要访问的页面，并且有Belady现象（类似于逆向优化的现，增加内存的大小，很难降低缺页率），FIFO很少单独使用</p></blockquote>\n</li>\n</ul>\n<h3 id=\"【3】最近最久未使用（LRU）\"><a href=\"#【3】最近最久未使用（LRU）\" class=\"headerlink\" title=\"【3】最近最久未使用（LRU）\"></a>【3】最近最久未使用（LRU）</h3><ul>\n<li><p><strong>思路：</strong>选择最久未使用的那个页面置换。是对最优页面置换算法的近似，根据过去推测未来。</p>\n</li>\n<li><p>操作系统具体可以用以下方法实现：</p>\n<ul>\n<li>维护一个链表，刚使用的放表头，最久未使用的作为尾节点。每次访问内存时，找到相应的页面，把它移到表头。发生缺页中断后，淘汰链表末尾的页面。</li>\n<li>设置一个活动栈，访问页面时，将次页号压入栈顶，将栈内相同的页号都删掉。每次总是置换栈底元素。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>LRU性能较好，但需要寄存器和栈的硬件支持，LRU是堆栈类的算法</p>\n<p>理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。</p></blockquote>\n</li>\n</ul>\n<h3 id=\"【4】时钟（CLOCK）\"><a href=\"#【4】时钟（CLOCK）\" class=\"headerlink\" title=\"【4】时钟（CLOCK）\"></a>【4】时钟（CLOCK）</h3><ul>\n<li><p>利用页表中的访问位（Access Bit），初始化为0，每次访问后都会置为1，操作系统又定期将其变为0。</p>\n</li>\n<li><p><strong>思路：</strong>当发生缺页中断时，若当前访问位&#x3D;&#x3D;1则置0，指针向下走，直到遇到访问位&#x3D;&#x3D;0的页面就进行置换；若当前访问位&#x3D;&#x3D;0则置换该页，然后指针指向下一个地址。在这个过程中，指针类似于时钟往一个方向走。</p>\n</li>\n</ul>\n","feature":true,"text":"一、进程、线程、协程1.进程【1】定义 保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体 这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统 【2】特点 操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位 【3...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"操作系统","slug":"操作系统","count":1,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">一、进程、线程、协程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">1.进程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">【1】定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">【2】特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E8%BF%9B%E7%A8%8B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">【3】进程常见状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%904%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">【4】进程间通信</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">2.线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E5%AE%9A%E4%B9%89-1\"><span class=\"toc-text\">【1】定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">【2】线程常见状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E7%BA%BF%E7%A8%8B%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">【3】线程类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%904%E3%80%91%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">【4】线程同步方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8C%BA%E5%88%AB%EF%BC%89\"><span class=\"toc-text\">3. 进程和线程（区别）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">4.协程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E5%AE%9A%E4%B9%89-2\"><span class=\"toc-text\">【1】定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">【2】特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E6%AF%94\"><span class=\"toc-text\">【3】协程与多线程相比</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%904%E3%80%91%E5%8F%82%E8%80%83%E4%BE%8B%E5%AD%90%EF%BC%88lua%E5%8D%8F%E7%A8%8B%EF%BC%89\"><span class=\"toc-text\">【4】参考例子（lua协程）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">5.进程调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E8%B0%83%E5%BA%A6%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">【1】调度种类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">【2】调度方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">【3】进程调度算法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">二、死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1.定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">2.四个必要条件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.如何预防死锁问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E7%A0%B4%E5%9D%8F%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E4%B9%8B%E4%B8%80\"><span class=\"toc-text\">【1】破坏四个必要条件之一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E6%9C%89%E5%BA%8F%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%B3%95\"><span class=\"toc-text\">【2】有序资源分配法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95-%E6%9C%80%E5%85%B7%E4%BB%A3%E8%A1%A8%E6%80%A7\"><span class=\"toc-text\">【3】银行家算法(最具代表性)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">4.如何检测死锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%A6%82%E4%BD%95%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">5.如何解除死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">【1】终止进程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E6%92%A4%E9%94%80%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%89%A5%E5%A4%BA%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">【2】撤销进程，剥夺资源</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E8%BF%9B%E7%A8%8B%E5%9B%9E%E9%80%80%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">【3】进程回退策略</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">三、内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.连续分配管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">【1】固定分区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">【2】动态分区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">【3】伙伴系统</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">2.非连续分配管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E5%88%86%E6%AE%B5\"><span class=\"toc-text\">【1】分段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E5%88%86%E9%A1%B5\"><span class=\"toc-text\">【2】分页</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">四、虚拟内存技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">2.基本思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%89%B9%E5%BE%81%E4%BD%8D\"><span class=\"toc-text\">3.特征位</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">4.基本流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%B8%B8%E8%A7%81%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">5.常见置换算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89\"><span class=\"toc-text\">【1】最佳置换算法（OPT）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%88FIFO%EF%BC%89\"><span class=\"toc-text\">【2】先进先出（FIFO）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%EF%BC%88LRU%EF%BC%89\"><span class=\"toc-text\">【3】最近最久未使用（LRU）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%904%E3%80%91%E6%97%B6%E9%92%9F%EF%BC%88CLOCK%EF%BC%89\"><span class=\"toc-text\">【4】时钟（CLOCK）</span></a></li></ol></li></ol></li></ol>","author":{"name":"ARBIN","slug":"arbin","avatar":"https://s2.loli.net/2023/04/04/dZv3NaCepc7X4MO.jpg","link":"/","description":"立志成为潮流研究生","socials":{"github":"https://github.com/Aidongo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Notion":{"icon":"/svg/icons8-notion-48.png","link":"https://arbin29.notion.site/ARBIN-HomePage-641b7c55779f4920869022cad678e8a5"}}}},"mapped":true,"prev_post":{"title":"LeetCode 数组","uid":"a82004346219b89210300085e2164ae5","slug":"面试攻略/数组","date":"2023-04-04T01:37:00.000Z","updated":"2023-04-04T01:46:00.260Z","comments":true,"path":"api/articles/面试攻略/数组.json","keywords":null,"cover":[],"text":"数组理论基础概念：数组是存放在连续内存空间上的相同类型数据的集合 字符数组例子： 数组下标都是从0开始的。 数组内存空间的地址是连续的 二维数组 Java的二维数组在内存中不是 3*4 的连续地址空间，而是四条连续的地址空间组成 704. 二分查找题目给定一个 n 个元素有序的（...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"LeetCode","slug":"LeetCode","count":1,"path":"api/categories/LeetCode.json"}],"tags":[{"name":"数组","slug":"数组","count":1,"path":"api/tags/数组.json"}],"author":{"name":"ARBIN","slug":"arbin","avatar":"https://s2.loli.net/2023/04/04/dZv3NaCepc7X4MO.jpg","link":"/","description":"立志成为潮流研究生","socials":{"github":"https://github.com/Aidongo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Notion":{"icon":"/svg/icons8-notion-48.png","link":"https://arbin29.notion.site/ARBIN-HomePage-641b7c55779f4920869022cad678e8a5"}}}},"feature":true},"next_post":{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"Computer Basis/计算机网络知识点","date":"2023-04-03T16:35:00.000Z","updated":"2023-04-04T03:04:26.896Z","comments":true,"path":"api/articles/Computer Basis/计算机网络知识点.json","keywords":null,"cover":[],"text":"相关博客 一、体系结构 OSI 七层模型 TCP&#x2F;IP 四层模型 TCP&#x2F;IP 五层模型 ​ 1.物理层 数据传输单位： 比特（bit） 作用： 激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性 设备： 中继器、集线器 2.数据链路层 数...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/tags/计算机网络.json"},{"name":"面试知识点","slug":"面试知识点","count":1,"path":"api/tags/面试知识点.json"}],"author":{"name":"ARBIN","slug":"arbin","avatar":"https://s2.loli.net/2023/04/04/dZv3NaCepc7X4MO.jpg","link":"/","description":"立志成为潮流研究生","socials":{"github":"https://github.com/Aidongo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Notion":{"icon":"/svg/icons8-notion-48.png","link":"https://arbin29.notion.site/ARBIN-HomePage-641b7c55779f4920869022cad678e8a5"}}}},"feature":true}}