{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"Computer Basis/计算机网络知识点","date":"2023-04-03T16:35:00.000Z","updated":"2023-04-04T01:19:19.879Z","comments":true,"path":"api/articles/Computer Basis/计算机网络知识点.json","keywords":null,"cover":[],"content":"<p><a href=\"https://www.cnblogs.com/inception6-lxc/p/9152691.html\">相关博客</a></p>\n<h1 id=\"一、体系结构\"><a href=\"#一、体系结构\" class=\"headerlink\" title=\"一、体系结构\"></a>一、体系结构</h1><ul>\n<li><strong>OSI 七层模型</strong></li>\n<li><strong>TCP&#x2F;IP 四层模型</strong></li>\n<li><strong>TCP&#x2F;IP 五层模型</strong></li>\n</ul>\n<p>​\t<img src=\"https://s2.loli.net/2023/04/04/xIPSk1tAZ2BRw4H.png\" alt=\"五层体系结构\" style=\"zoom:50%;\" /></p>\n<hr>\n<h2 id=\"1-物理层\"><a href=\"#1-物理层\" class=\"headerlink\" title=\"1.物理层\"></a>1.物理层</h2><ul>\n<li><strong>数据传输单位：</strong> 比特（bit）</li>\n<li><strong>作用：</strong> 激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性</li>\n<li><strong>设备：</strong> 中继器、集线器</li>\n</ul>\n<h2 id=\"2-数据链路层\"><a href=\"#2-数据链路层\" class=\"headerlink\" title=\"2.数据链路层\"></a>2.数据链路层</h2><ul>\n<li><strong>数据传输单位</strong>：帧（frame）</li>\n<li><strong>作用</strong>：在 <strong><u>物理层</u></strong> 提供的服务基础向上 <strong><u>网络层</u></strong> 提供服务，将源自网络层的数据可靠地传输到相邻节点得目标机网络层<ul>\n<li><strong>封装成帧</strong>：将上层传下来得IP数据报加上首部和尾部（包括许多控制信息）</li>\n<li><strong>透明传输</strong></li>\n<li><strong>差错检测</strong></li>\n</ul>\n</li>\n<li><strong>设备：</strong>网桥、交换机</li>\n<li><strong>协议：VLAN、MAC、PPP、以太网</strong></li>\n</ul>\n<h2 id=\"3-网络层\"><a href=\"#3-网络层\" class=\"headerlink\" title=\"3.网络层\"></a>3.网络层</h2><ul>\n<li><strong>数据传输单位：</strong>IP数据报</li>\n<li><strong>作用：实现两个主机系统之间的数据透明传送</strong><ul>\n<li>路径选择</li>\n<li>路由</li>\n<li>逻辑寻址</li>\n</ul>\n</li>\n<li><strong>协议</strong><ul>\n<li><strong>IP 协议</strong></li>\n<li><strong>ICMP 协议</strong></li>\n<li><strong>ARP 协议 （MAC）</strong></li>\n</ul>\n</li>\n<li><strong>设备：</strong>路由器</li>\n</ul>\n<h2 id=\"4-运输层（Socket）\"><a href=\"#4-运输层（Socket）\" class=\"headerlink\" title=\"4.运输层（Socket）\"></a>4.运输层（Socket）</h2><ul>\n<li><strong>数据传输单位：</strong>TCP报文 &#x2F;  UDP报文</li>\n<li><strong>作用：</strong>负责向**<u>两台主机进程</u>**之间的通信提供通用的数据传输服务</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>网络层</strong>只是根据网络地址将源节点发出的数据包传送到目的节点，而<strong>传输层</strong>则负责将数据可靠地传送到相应的端口。</p></blockquote>\n<ul>\n<li><strong>协议</strong><ul>\n<li><strong>TCP（传输控制协议）：</strong>提供**<u>面向连接</u><strong>的，</strong><u>可靠的</u>**数据传输服务</li>\n<li><strong>UDP（用户数据协议）：</strong>提供**<u>无连接</u><strong>的，尽最大努力的数据传输服务（</strong><u>不保证数据传输的可靠性</u>**）</li>\n</ul>\n</li>\n<li><strong>设备：</strong>网关</li>\n</ul>\n<h2 id=\"5-会话层、表示层\"><a href=\"#5-会话层、表示层\" class=\"headerlink\" title=\"5.会话层、表示层\"></a>5.会话层、表示层</h2><h3 id=\"【1】会话层\"><a href=\"#【1】会话层\" class=\"headerlink\" title=\"【1】会话层\"></a>【1】会话层</h3><ul>\n<li><strong>作用：</strong>管理主机之间的<strong>会话进程</strong>，即负责建立、管理、终止进程之间的会话</li>\n<li>利用在数据中插入校验点来实现数据的同步</li>\n</ul>\n<h3 id=\"【2】表示层\"><a href=\"#【2】表示层\" class=\"headerlink\" title=\"【2】表示层\"></a>【2】表示层</h3><ul>\n<li><strong>作用：</strong>对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解</li>\n<li><strong>数据转换：</strong>数据的加密、压缩、格式转换</li>\n</ul>\n<h2 id=\"6-应用层（最靠近用户的OSI层）\"><a href=\"#6-应用层（最靠近用户的OSI层）\" class=\"headerlink\" title=\"6. 应用层（最靠近用户的OSI层）\"></a>6. 应用层（最靠近用户的OSI层）</h2><ul>\n<li><strong>作用：<u>通过利用对应进程间的交互来完成特定网络作用</u></strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>应用层协议当以的是**<u>应用进程</u>**间的通信和交互的规则</p></blockquote>\n<ul>\n<li><p><strong>协议</strong></p>\n<ul>\n<li><p><strong>FTP（文件传送协议）</strong></p>\n</li>\n<li><p><strong>Telnet（远程登陆协议）</strong></p>\n</li>\n<li><p><strong>DNS协议</strong><code>（作为可以将域名和IP地址相互映射的一个分布式数据库，IP与域名的映射）</code></p>\n</li>\n<li><p><strong>SMTP（邮件传送协议）</strong></p>\n</li>\n<li><p><strong>POP3（邮局协议）</strong></p>\n</li>\n<li><p><strong>HTTP协议（超文本传输协议）</strong></p>\n<p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"二、IP\"><a href=\"#二、IP\" class=\"headerlink\" title=\"二、IP\"></a>二、IP</h1><h2 id=\"1-IP地址划分\"><a href=\"#1-IP地址划分\" class=\"headerlink\" title=\"1.IP地址划分\"></a>1.IP地址划分</h2><p><strong>网络号（net-id）：</strong>标识主机或路由器所连到的网</p>\n<p><strong>主机号（host-id）：</strong>标志该主机（或路由器）</p>\n<ul>\n<li>A类地址以0开头：第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255</li>\n<li>B类地址以10开头：前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255</li>\n<li>C类地址以110开头：前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255</li>\n<li>D类地址以1110开头：地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）</li>\n<li>E类地址以1111开头：地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2023/04/04/RxYQeylqIsX9gD4.jpg\"  />****</p>\n<h2 id=\"2-子网划分\"><a href=\"#2-子网划分\" class=\"headerlink\" title=\"2.子网划分\"></a>2.子网划分</h2><ul>\n<li><p><strong>作用：</strong>在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号 </p>\n <img src=\"https://s2.loli.net/2023/04/04/RyhcQSKtILH7dzq.png\" style=\"zoom: 33%;\" /></li>\n</ul>\n<p><strong>子网掩码</strong></p>\n<ul>\n<li><strong>定义：</strong>标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位</li>\n<li><strong>计算：</strong>通过 IP地址 与 子网掩码 与运算得到网络地址</li>\n<li>相关博文：<a href=\"https://www.cnblogs.com/inception6-lxc/p/9152691.html\">https://www.cnblogs.com/inception6-lxc/p/9152691.html</a></li>\n</ul>\n<hr>\n<h1 id=\"三、协议\"><a href=\"#三、协议\" class=\"headerlink\" title=\"三、协议\"></a>三、协议</h1><h2 id=\"1-ARP-x2F-RARP\"><a href=\"#1-ARP-x2F-RARP\" class=\"headerlink\" title=\"1.ARP&#x2F;RARP\"></a>1.ARP&#x2F;RARP</h2><h3 id=\"【1】ARP的（地址解析协议）\"><a href=\"#【1】ARP的（地址解析协议）\" class=\"headerlink\" title=\"【1】ARP的（地址解析协议）\"></a>【1】ARP的（地址解析协议）</h3><ul>\n<li><p><strong>定义：地址解析协议，即ARP（Address Resolution Protocol），是根据<u>IP地址获取物理地址</u>的一个TCP&#x2F;IP协议</strong></p>\n<p><strong><code>（通过网络层使用的IP地址解析得出链路层使用的硬件地址）</code></strong></p>\n</li>\n<li><p><strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等</strong></p>\n</li>\n<li><p><strong>工作流程</strong></p>\n<ol>\n<li>每个主机在自己的ARP缓冲区建立一个ARP列表，以表示 &#x3D;&#x3D;IP地址&#x3D;&#x3D; 和 &#x3D;&#x3D;MAC地址&#x3D;&#x3D;</li>\n<li>当主机A欲向本局域网的主机B发送IP数据报时，首先在ARP高速缓冲区中查看有无主机B的IP地址<ul>\n<li><strong>如有：</strong>即可通过对应IP地址查出硬件地址，将硬件地址写入MAC帧，通过局域网将MAC帧发送此硬件地址</li>\n<li><strong>如无：</strong>ARP进程在本局域网广播发送一个ARP请求分组（源主机IP地址，源主机MAC地址，目的主机IP地址）</li>\n</ul>\n</li>\n<li>当本网络所有主机收到该ARP时，检查ARP请求分组中的<strong>目的IP地址</strong>是否为本机<ul>\n<li><strong>若不是</strong>：忽略该分组</li>\n<li><strong>若是</strong>：首先将源主机IP和MAC地址取出存入ARP列表（添加或覆盖），并将本机MAC地址写入ARP响应分组中</li>\n</ul>\n</li>\n<li>若源主机一直没收到ARP响应分组则表示ARP查询失败</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"【2】RARP\"><a href=\"#【2】RARP\" class=\"headerlink\" title=\"【2】RARP\"></a>【2】RARP</h4><ul>\n<li><p><strong>定义：功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p>\n<ul>\n<li>比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</li>\n</ul>\n</li>\n<li><p><strong>工作流程</strong></p>\n<ol>\n<li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址</li>\n<li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址</li>\n<li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li>\n<li>如果不存在，RARP服务器对此不做任何的响应</li>\n<li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-TCP-x2F-UDP\"><a href=\"#2-TCP-x2F-UDP\" class=\"headerlink\" title=\"2.TCP&#x2F;UDP\"></a>2.TCP&#x2F;UDP</h2><h3 id=\"【1】TCP（传输控制协议，Transmission-Control-Protocl）\"><a href=\"#【1】TCP（传输控制协议，Transmission-Control-Protocl）\" class=\"headerlink\" title=\"【1】TCP（传输控制协议，Transmission Control Protocl）\"></a>【1】TCP（传输控制协议，Transmission Control Protocl）</h3><ul>\n<li><p><strong>定义：是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong></p>\n</li>\n<li><p><strong>应用场景：</strong>当对网络通讯质量有要求的时候，整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">协议</th>\n<th>定义</th>\n<th>端口号</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">FTP</td>\n<td>文件传输协议</td>\n<td>21</td>\n</tr>\n<tr>\n<td align=\"left\">Telnet</td>\n<td>用于远程登陆的端口<br/>用户可以以自己的身份远程连接到计算机上可提供基于DOS模式下的通信服务</td>\n<td>23</td>\n</tr>\n<tr>\n<td align=\"left\">SMTP</td>\n<td>邮件传送协议，用于发送邮件</td>\n<td>25</td>\n</tr>\n<tr>\n<td align=\"left\">POP3</td>\n<td>和SMTP对应，POP3用于接收邮件</td>\n<td>110</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP</td>\n<td>Web服务器传输超文本到本地浏览器的传送协议</td>\n<td>80</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>报文标志位</strong></p>\n<ul>\n<li><strong>URG:</strong> 标识紧急指针是否有效</li>\n<li><strong>ACK:</strong> 标识确认序号是否有效</li>\n<li><strong>PSH:</strong> 用来提示接收端应用程序立刻将数据从tcp缓冲区读走</li>\n<li><strong>RST:</strong> 要求重新建立连接. 我们把含有RST标识的报文称为复位报文段</li>\n<li><strong>SYN:</strong> 请求建立连接. 我们把含有SYN标识的报文称为同步报文段</li>\n<li><strong>FIN:</strong> 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为结束报文段</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"【2】UDP-用户数据报协议，User-Datagram-Protocol）\"><a href=\"#【2】UDP-用户数据报协议，User-Datagram-Protocol）\" class=\"headerlink\" title=\"【2】UDP(用户数据报协议，User Datagram Protocol）\"></a>【2】UDP(用户数据报协议，User Datagram Protocol）</h3><ul>\n<li><strong>定义: 支持无连接的传输协议, 功能即为在IP的数据报服务之上增加了最基本的服务复用和分用以及差错检测</strong></li>\n<li><strong>应用场景:</strong> 当强调<code>传输性能</code>而不是传输的完整性时， 要求网络通讯速度能尽量的快。如：QQ语音 QQ视频等。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">协议</th>\n<th>定义</th>\n<th>端口号</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DNS</td>\n<td>域名解析服务，将域名地址转换为IP地址</td>\n<td>53</td>\n</tr>\n<tr>\n<td align=\"left\">SNMP</td>\n<td>简单网络管理协议</td>\n<td>161</td>\n</tr>\n<tr>\n<td align=\"left\">TFTP</td>\n<td>简单文件传输协议</td>\n<td>69</td>\n</tr>\n</tbody></table>\n<h3 id=\"【3】TCP-和-UDP-区别\"><a href=\"#【3】TCP-和-UDP-区别\" class=\"headerlink\" title=\"【3】TCP 和 UDP 区别\"></a>【3】TCP 和 UDP 区别</h3><table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">UDP</th>\n<th>TCP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">是否连接</td>\n<td align=\"left\">无连接</td>\n<td>面向连接</td>\n</tr>\n<tr>\n<td align=\"left\">是否可靠</td>\n<td align=\"left\">不可靠传输，不使用流量控制和拥塞控制</td>\n<td>可靠传输，使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td align=\"left\">连接对象个数</td>\n<td align=\"left\">支持一对一，一对多，多对一和多对多交互通信</td>\n<td>只能是一对一通信</td>\n</tr>\n<tr>\n<td align=\"left\">传输方式</td>\n<td align=\"left\">面向报文</td>\n<td>面向字节流</td>\n</tr>\n<tr>\n<td align=\"left\">首部开销</td>\n<td align=\"left\">首部开销小，仅8字节</td>\n<td>首部最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td align=\"left\">适用场景</td>\n<td align=\"left\">适用于实时应用（IP电话、视频会议、直播等）</td>\n<td>适用于要求可靠传输的应用，例如文件传输</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"3-TCP流量控制-x2F-拥塞控制\"><a href=\"#3-TCP流量控制-x2F-拥塞控制\" class=\"headerlink\" title=\"3.TCP流量控制&#x2F;拥塞控制\"></a>3.TCP流量控制&#x2F;拥塞控制</h2><h3 id=\"【1】流量控制\"><a href=\"#【1】流量控制\" class=\"headerlink\" title=\"【1】流量控制\"></a>【1】流量控制</h3><ul>\n<li><strong>手段：滑动窗口实现流量控制</strong></li>\n<li><strong>目的：控制发送方发送速率，保证接收方来得及接收。</strong></li>\n<li><strong>基本实现</strong><ul>\n<li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率</li>\n<li>将窗口字段设置为 0，则发送方不能发送数据。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"【2】拥塞控制\"><a href=\"#【2】拥塞控制\" class=\"headerlink\" title=\"【2】拥塞控制\"></a>【2】拥塞控制</h4><ul>\n<li><strong>拥塞：</strong>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏</li>\n<li><strong>作用：</strong>防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载</li>\n<li><strong>前提：</strong>网络能够承受现有的网络负荷</li>\n<li><strong>全局性过程</strong><ul>\n<li>涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li>\n<li><strong>流量控制：</strong>是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>\n</ul>\n</li>\n</ul>\n<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong></p>\n<p>在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>拥塞窗口(cwnd)：</strong>发送方需要维持的状态变量<ul>\n<li>拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化</li>\n<li>发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</li>\n</ul>\n</li>\n<li><strong>慢开始</strong> <ul>\n<li><strong>思路：</strong>由小到大逐渐增大拥塞窗口数值，cwnd &#x3D; 1</li>\n<li><strong>每经过一个传输轮次</strong>，cwnd *&#x3D; 2</li>\n<li>设置慢开始门限状态变量ssthresh<ul>\n<li>cwnd &lt; ssthresh ，使用慢开始算法</li>\n<li>cwnd &gt; ssthresh ，停止使用慢开始算法改用拥塞避免算法</li>\n<li>cwnd &#x3D; ssthresh，既可使用慢开始也可使用拥塞避免</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>拥塞避免</strong> <ul>\n<li><strong>思路：</strong>让拥塞窗口cwnd缓慢增大</li>\n<li><strong>每经过一个传输轮次</strong>，cwnd +&#x3D; 1</li>\n</ul>\n</li>\n<li><strong>快重传与快恢复：</strong>快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法<ul>\n<li>能快速恢复丢失的数据包</li>\n<li>有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认</li>\n<li><strong>快重传：</strong>如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段</li>\n<li><strong>快恢复：</strong>当执行完快重传时，执行快恢复算法<ul>\n<li>慢开始门限 <code>ssthresh</code> &#x3D; 当前拥塞窗口 <code>cwnd / 2</code></li>\n<li>新拥塞窗口 <code>cwnd</code> &#x3D; 慢开始门限 <code>ssthresh</code></li>\n<li><strong>开始执行拥塞避免算法</strong>，使阻塞窗口缓慢地先行增大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>当网络出现拥塞（重传定时器超时）</strong></p>\n<ol>\n<li><p><strong>sshthres &#x3D; max（cwnd&#x2F;2 , 2）</strong></p>\n</li>\n<li><p><strong>cwnd &#x3D; 1</strong></p>\n</li>\n<li><p><strong>执行慢开始方法</strong></p>\n<p>目的：迅速减少主机发送到网络中的分组数，使得发生拥塞得路由器有足够得时间把队列中积压的分组处理完毕</p>\n</li>\n</ol></blockquote>\n<p> <img src=\"https://s2.loli.net/2023/04/04/RYekiZUhnBpDI61.png\" alt=\"image-20210725144251829\"></p>\n<hr>\n<h2 id=\"4-ARQ协议\"><a href=\"#4-ARQ协议\" class=\"headerlink\" title=\"4.ARQ协议\"></a>4.ARQ协议</h2><ul>\n<li><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）<ul>\n<li>OSI模型中数据链路层和传输层的错误纠正协议之一</li>\n<li>通过使用<u><strong>确认</strong></u>和<u><strong>超时</strong></u>这两个机制，<strong>在不可靠服务的基础上实现可靠的信息传输</strong></li>\n<li>如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送</li>\n<li>ARQ包括停止等待ARQ协议和连续ARQ协议。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"【1】停止等待ARQ协议\"><a href=\"#【1】停止等待ARQ协议\" class=\"headerlink\" title=\"【1】停止等待ARQ协议\"></a>【1】停止等待ARQ协议</h3><ul>\n<li><strong>作用：实现可靠传输</strong></li>\n<li><strong>基本原理：</strong>每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p></blockquote>\n<ul>\n<li><strong>优缺点：</strong><ul>\n<li><strong>优点：</strong> 简单</li>\n<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>\n</ul>\n</li>\n</ul>\n<p><strong>(1)无差错情况:</strong></p>\n<ul>\n<li>发送方发送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送。</li>\n</ul>\n<p><strong>(2)出现差错情况（超时重传）:</strong></p>\n<ul>\n<li>只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）</li>\n<li>因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> </li>\n<li>在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认</li>\n</ul>\n<p><strong>(3)确认丢失和确认迟到</strong></p>\n<ul>\n<li><strong>确认丢失</strong> ：确认消息在传输过程丢失<ul>\n<li>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失</li>\n<li>而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：<ul>\n<li>丢弃这个重复的M1消息，不向上层交付。</li>\n<li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到<ul>\n<li>A发送M1消息，B收到并发送确认</li>\n<li>在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）</li>\n<li>此时A收到了B第二次发送的确认消息，接着发送其他数据</li>\n<li>过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息），处理如下：<ul>\n<li>A收到重复的确认后，直接丢弃</li>\n<li>B收到重复的M1后，也直接丢弃重复的M1。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"【2】连续ARQ协议\"><a href=\"#【2】连续ARQ协议\" class=\"headerlink\" title=\"【2】连续ARQ协议\"></a>【2】连续ARQ协议</h3><ul>\n<li><p><strong>基本原理</strong></p>\n<ul>\n<li>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认</li>\n<li>接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</li>\n</ul>\n</li>\n<li><p><strong>优缺点：</strong></p>\n<ul>\n<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传</li>\n<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息<ul>\n<li>比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"5-HTTP（超文本传输协议）\"><a href=\"#5-HTTP（超文本传输协议）\" class=\"headerlink\" title=\"5.HTTP（超文本传输协议）\"></a>5.HTTP（超文本传输协议）</h2><ul>\n<li><strong>定义：基于TCP&#x2F;IP通信协议来传递数据的一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型；默认端口80</strong></li>\n<li><strong>工作原理：HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端</strong></li>\n</ul>\n<h3 id=\"【1】HTTP-请求-x2F-响应的步骤\"><a href=\"#【1】HTTP-请求-x2F-响应的步骤\" class=\"headerlink\" title=\"【1】HTTP 请求&#x2F;响应的步骤\"></a>【1】HTTP 请求&#x2F;响应的步骤</h3><ol>\n<li><p><strong>客户端连接到Web服务器</strong></p>\n<ul>\n<li>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接</li>\n<li>例如：<a href=\"http://www.oakcms.cn/\">http://www.oakcms.cn</a></li>\n</ul>\n</li>\n<li><p><strong>发送HTTP请求</strong></p>\n<ul>\n<li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文</li>\n<li>一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li>\n</ul>\n</li>\n<li><p><strong>服务器接受请求并返回HTTP响应</strong></p>\n<ul>\n<li>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取</li>\n<li>一个响应由<strong>状态行</strong>、<strong>响应头部</strong>、<strong>空行</strong>和<strong>响应数据</strong>4部分组成。</li>\n</ul>\n</li>\n<li><p><strong>释放连接TCP连接</strong></p>\n<ul>\n<li>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接</li>\n<li>若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求</li>\n</ul>\n</li>\n<li><p><strong>客户端浏览器解析HTML内容</strong></p>\n<ul>\n<li>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码</li>\n<li>然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集</li>\n<li>客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"HTTP常见状态码\"><a href=\"#HTTP常见状态码\" class=\"headerlink\" title=\"HTTP常见状态码\"></a>HTTP常见状态码</h3><ul>\n<li><p><strong>2xx：（成功）成功处理了请求的状态代码</strong></p>\n<ul>\n<li>200 (成功) ：服务器已成功处理了请求</li>\n</ul>\n</li>\n<li><p><strong>3xx：（重定向）要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong></p>\n<ul>\n<li><strong>304 (未修改) ：</strong>自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容</li>\n</ul>\n</li>\n<li><h5 id=\"4xx：-客户端请求错误-请求有语法错误或请求无法实现\"><a href=\"#4xx：-客户端请求错误-请求有语法错误或请求无法实现\" class=\"headerlink\" title=\"4xx：(客户端请求错误) 请求有语法错误或请求无法实现\"></a>4xx：(客户端请求错误) 请求有语法错误或请求无法实现</h5><ul>\n<li><strong>400 (错误请求)</strong> 服务器不理解请求的语法</li>\n<li><strong>403 (禁止)</strong> 服务器拒绝请求</li>\n<li><strong>404 (未找到)</strong> 服务器找不到请求的网页。</li>\n</ul>\n</li>\n<li><h5 id=\"5xx：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错\"><a href=\"#5xx：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错\" class=\"headerlink\" title=\"5xx：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错\"></a>5xx：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错</h5><ul>\n<li><strong>500 (服务器内部错误)：</strong> 服务器遇到错误，无法完成请求</li>\n<li><strong>501 (尚未实施)：</strong> 服务器不具备完成请求的功能 例如，服务器无法识别请求方法时可能会返回此代码</li>\n<li><strong>502 (错误网关)：</strong> 服务器作为网关或代理，从上游服务器收到无效响应</li>\n<li><strong>503 (服务不可用)：</strong> 服务器目前无法使用(由于超载或停机维护)；通常，这只是暂时状态</li>\n<li><strong>504 (网关超时)：</strong> 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li>\n<li><strong>505 (HTTP 版本不受支持)：</strong> 服务器不支持请求中所用的 HTTP 协议版本。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"常见HTTP首部字段\"><a href=\"#常见HTTP首部字段\" class=\"headerlink\" title=\"常见HTTP首部字段\"></a>常见HTTP首部字段</h4><ul>\n<li><a href=\"https://www.cnblogs.com/chenxizhaolu/p/7591549.html\">相关博文</a></li>\n</ul>\n<hr>\n<h2 id=\"6-HTTPS\"><a href=\"#6-HTTPS\" class=\"headerlink\" title=\"6.HTTPS\"></a>6.HTTPS</h2><ul>\n<li><strong>定义：一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL&#x2F;TLS建立全信道，加密数据包</strong></li>\n<li><strong>主要目的：提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性</strong></li>\n</ul>\n<p><strong>工作原理</strong></p>\n<ol>\n<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li>\n<li>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端</li>\n<li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级</li>\n<li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>\n<li>Web服务器利用自己的私钥解密出会话密钥</li>\n<li>Web服务器利用会话密钥加密与客户端之间的通信</li>\n</ol>\n<p> <img src=\"https://s2.loli.net/2023/04/04/KW45kFXgDRStnie.gif\" alt=\"img\" style=\"zoom: 67%;\" /><img src=\"https://s2.loli.net/2023/04/04/WM42ubyL5mV3PCf.png\" alt=\"在这里插入图片描述\" style=\"zoom:33%;\" /></p>\n<ul>\n<li><strong>相关博文</strong><ul>\n<li><a href=\"https://www.cnblogs.com/wqhwe/p/5407468.html\">HTTPS工作原理</a></li>\n<li><a href=\"https://blog.csdn.net/mzh1992/article/details/53885098\">较好理解的一个链接</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-SSL协议\"><a href=\"#7-SSL协议\" class=\"headerlink\" title=\"7.SSL协议\"></a>7.SSL协议</h2><ul>\n<li><strong>定义：</strong>位于可靠的面向连接的<strong>网络层协议</strong>和<strong>应用层协议</strong>之间的一种<strong>协议层</strong><ul>\n<li>SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯</li>\n</ul>\n</li>\n<li><strong>由两层组成</strong><ul>\n<li>&#x3D;&#x3D;SSL记录协议:&#x3D;&#x3D;建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能</li>\n<li>&#x3D;&#x3D;SSL握手协议:&#x3D;&#x3D;建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等</li>\n</ul>\n</li>\n<li><strong>SSL握手</strong><ul>\n<li>客户端发送 Client Hello 报文开始 SSL通信。</li>\n<li>报文中包含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li>\n<li>服务器以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。</li>\n<li>服务器发送 Certificate 报文。报文中包含公开密钥证书。</li>\n<li>最后服务器发送 Server Hello Done 报文通知客户端。</li>\n<li>客户端以 Client Key Exchange 报文作为回应。</li>\n<li>报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li>\n<li>客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</li>\n<li>客户端发送 Finished 报文。</li>\n<li>服务器发送 Change Cipher Spec 报文。</li>\n<li>服务器发送 Finished 报文</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"四、面试题\"><a href=\"#四、面试题\" class=\"headerlink\" title=\"四、面试题\"></a>四、面试题</h1><h2 id=\"1-TCP协议如何保证可靠传输\"><a href=\"#1-TCP协议如何保证可靠传输\" class=\"headerlink\" title=\"1.TCP协议如何保证可靠传输\"></a>1.TCP协议如何保证可靠传输</h2><ol>\n<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>\n<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>\n<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>\n<li>TCP 的接收端会丢弃重复的数据。</li>\n<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>\n<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>\n<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>\n<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>\n</ol>\n<hr>\n<h2 id=\"2-TCP连接\"><a href=\"#2-TCP连接\" class=\"headerlink\" title=\"2.TCP连接\"></a>2.TCP连接</h2><p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器</strong></p>\n<ol>\n<li><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了<strong>LISTEN（监听）状态</strong>；</p>\n</li>\n<li><p>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文</p>\n<ul>\n<li><p>报文首部中的同步位<strong>SYN&#x3D;1</strong>，同时选择一个初始序列号 <strong>seq&#x3D;x</strong> ，<strong>TCP客户端</strong>进程进入 <strong>SYN-SENT（同步已发送状态）状态</strong></p>\n</li>\n<li><p>TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号</p>\n</li>\n</ul>\n</li>\n<li><p>TCP服务器收到请求报文后，如果同意连接，则发出确认报文</p>\n<ul>\n<li>确认报文中应该 <strong>ACK&#x3D;1</strong>，<strong>SYN&#x3D;1</strong>，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 <strong>seq&#x3D;y</strong></li>\n<li>此时，TCP服务器进程进入了<strong>SYN-RCVD（同步收到）状态</strong>。这个报文也不能携带数据，但是同样要<strong>消耗一个序号</strong>。</li>\n</ul>\n</li>\n<li><p>TCP客户进程收到确认后，还要向服务器给出确认</p>\n<ul>\n<li>确认报文的<strong>ACK&#x3D;1</strong>，<strong>ack&#x3D;y+1</strong>，自己的序列号seq&#x3D;x+1</li>\n<li>TCP连接建立，客户端进入<strong>ESTABLISHED（已建立连接）状态</strong></li>\n<li>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</li>\n</ul>\n</li>\n<li><p>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p>\n</li>\n</ol>\n<h4 id=\"问：为什么TCP客户端最后还要发送一次确认呢？\"><a href=\"#问：为什么TCP客户端最后还要发送一次确认呢？\" class=\"headerlink\" title=\"问：为什么TCP客户端最后还要发送一次确认呢？\"></a><strong>问：为什么TCP客户端最后还要发送一次确认呢？</strong></h4><p>   <strong>答：防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>如果使用的是两次握手建立连接</strong></p>\n<p>假设有这样一种场景</p>\n<ul>\n<li><p>客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文</p>\n</li>\n<li><p>此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的。但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要错误和资源的浪费</p>\n</li>\n<li><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>\n</li>\n</ul></blockquote>\n<img src=\"https://s2.loli.net/2023/04/04/pZGkCb2iIedmYXq.png\" alt=\"三次握手\" style=\"zoom:50%;\" />\n\n<hr>\n<h2 id=\"3-TCP连接释放\"><a href=\"#3-TCP连接释放\" class=\"headerlink\" title=\"3.TCP连接释放\"></a>3.TCP连接释放</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>数据传输完毕后，双方都可释放连接</strong></p>\n<p><strong>最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭</strong></p></blockquote>\n<ol>\n<li><strong>客户端进程发出连接释放报文，并且停止发送数据</strong><ul>\n<li>释放数据报文首部，<strong>FIN&#x3D;1</strong>，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1）</li>\n<li>客户端进入<strong>FIN-WAIT-1（终止等待1）状态</strong></li>\n<li>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>\n</ul>\n</li>\n<li><strong>服务器收到连接释放报文，发出确认报文</strong><ul>\n<li><strong>ACK&#x3D;1</strong>，<strong>ack&#x3D;u+1</strong>，并且带上自己的序列号<strong>seq&#x3D;v</strong></li>\n<li>服务端就进入了CLOSE-WAIT（关闭等待）状态</li>\n<li>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了</li>\n<li>这时候处于<strong>半关闭状态</strong>，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受</li>\n<li>这个状态还要持续一段时间，也就是整个<strong>CLOSE-WAIT</strong>状态持续的时间。</li>\n</ul>\n</li>\n<li><strong>客户端收到服务器的确认请求</strong><ul>\n<li>客户端就进入<strong>FIN-WAIT-2（终止等待2）状态</strong></li>\n<li>等待服务器发送连接释放报文（<strong>在这之前还需要接受服务器发送的最后的数据）</strong>。</li>\n</ul>\n</li>\n<li><strong>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</strong><ul>\n<li><strong>FIN&#x3D;1，ACK&#x3D;1</strong>，<strong>ack&#x3D;u+1</strong></li>\n<li>由于在半关闭状态，服务器很可能又发送了一些数据</li>\n<li>假定此时的序列号为<strong>seq&#x3D;w</strong></li>\n<li>服务器就进入了<strong>LAST-ACK（最后确认）状态</strong>，等待客户端的确认。</li>\n</ul>\n</li>\n<li><strong>客户端收到服务器的连接释放报文后，必须发出确认</strong><ul>\n<li>ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1</li>\n<li>客户端就进入了<strong>TIME-WAIT（时间等待）状态</strong></li>\n<li>注意此时TCP连接还没有释放，必须经过<strong>2*MSL（最长报文段寿命）</strong>的时间后，当客户端撤销相应的TCB后，才进入<strong>CLOSED状态</strong></li>\n</ul>\n</li>\n<li><strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态</strong><ul>\n<li>撤销TCB后，就结束了这次的TCP连接</li>\n<li>服务器结束TCP连接的时间要比客户端早一些。</li>\n</ul>\n</li>\n</ol>\n <img src=\"\\计算机网络知识点.assets\\aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy\" alt=\"四次挥手\" style=\"zoom: 50%;\" />\n\n<h4 id=\"【1】问：为什么客户端最后还要等待2MSL？\"><a href=\"#【1】问：为什么客户端最后还要等待2MSL？\" class=\"headerlink\" title=\"【1】问：为什么客户端最后还要等待2MSL？\"></a><code>【1】问：为什么客户端最后还要等待2MSL？</code></h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</strong></p></blockquote>\n<p><strong>答：保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失</strong></p>\n<ol>\n<li><p>站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个<strong>2MSL</strong>时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>\n</li>\n<li><p><strong>TIME_WAIT至少需要持续2MSL时长，这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失</strong></p>\n</li>\n</ol>\n<h4 id=\"【2】问：为什么建立连接是三次握手，关闭连接确是四次挥手呢？\"><a href=\"#【2】问：为什么建立连接是三次握手，关闭连接确是四次挥手呢？\" class=\"headerlink\" title=\"【2】问：为什么建立连接是三次握手，关闭连接确是四次挥手呢？\"></a><code>【2】问：为什么建立连接是三次握手，关闭连接确是四次挥手呢？</code></h4><p><strong>答：</strong></p>\n<ul>\n<li>建立连接时：服务器在<strong>LISTEN状态</strong>下，收到建立连接请求的SYN报文后，<strong>把ACK和SYN放在一个报文里发送给客户端</strong></li>\n<li>关闭连接时：服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。<strong>因此，己方ACK和FIN一般都会分开发送，从而导致多了一次</strong></li>\n</ul>\n<h4 id=\"【3】问：如果已经建立了连接，但是客户端突然出现故障了怎么办？\"><a href=\"#【3】问：如果已经建立了连接，但是客户端突然出现故障了怎么办？\" class=\"headerlink\" title=\"【3】问：如果已经建立了连接，但是客户端突然出现故障了怎么办？\"></a><code>【3】问：如果已经建立了连接，但是客户端突然出现故障了怎么办？</code></h4><p>答：TCP还设有一个保活计时器</p>\n<ul>\n<li>客户端如果出现故障，服务器不能一直等下去，白白浪费资源</li>\n<li>服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次</li>\n<li>若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li>\n</ul>\n<hr>\n<h2 id=\"4-DNS解析\"><a href=\"#4-DNS解析\" class=\"headerlink\" title=\"4.DNS解析\"></a>4.DNS解析</h2><ol>\n<li><p><strong>浏览器将会检查缓存中有没有这个域名对应的解析过的IP地址</strong></p>\n<ul>\n<li>如果有该解析过程将会结束</li>\n<li>浏览器缓存域名也是有限制的，包括缓存的时间、大小，可以通过TTL属性来设置。</li>\n</ul>\n</li>\n<li><p><strong>如果用户的浏览器中缓存中没有</strong></p>\n<ul>\n<li>操作系统会先检查自己本地的hosts文件是否有这个网址映射关系</li>\n<li>如果有，就先调用这个IP地址映射，完成域名解析。</li>\n</ul>\n</li>\n<li><p><strong>如果hosts里没有这个域名的映射</strong></p>\n<ul>\n<li>查找<strong>本地DNS解析器缓存</strong>，是否有这个网址映射关系</li>\n<li>如果有，直接返回，完成域名解析。</li>\n</ul>\n</li>\n<li><p><strong>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系</strong></p>\n<ul>\n<li>首先会找TCP&#x2F;ip参数中设置的<strong>首选DNS服务器（本地DNS服务器）</strong></li>\n<li>此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，<strong>此解析具有权威性</strong></li>\n</ul>\n</li>\n<li><p><strong>如果要查询的域名，不由本地DNS服务器区域解析</strong></p>\n<ul>\n<li>但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，<strong>此解析不具有权威性</strong></li>\n</ul>\n</li>\n<li><p><strong>如果本地DNS服务器本地区域文件与缓存解析都失效</strong></p>\n<ul>\n<li>则根据本地DNS服务器的设置（是否设置转发器）进行查询</li>\n<li>如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP</li>\n<li>本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器</li>\n<li>这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址给本地DNS服务器</li>\n<li>当本地DNS服务器收到这个地址后，就会找域名域服务器，重复上面的动作，进行查询，直至找到域名对应的主机。</li>\n</ul>\n</li>\n<li><p><strong>如果用的是转发模式</strong></p>\n<ul>\n<li>此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析</li>\n<li>上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环</li>\n<li>不管是本地DNS服务器用是是转发，还是迭代，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机</li>\n</ul>\n<img src=\"https://s2.loli.net/2023/04/04/wPiQsr7mMHn5kpV.png\" alt=\"img\" style=\"zoom:50%;\" /></li>\n</ol>\n<h2 id=\"5-在浏览器中输入www-baidu-com后执行的全部过程\"><a href=\"#5-在浏览器中输入www-baidu-com后执行的全部过程\" class=\"headerlink\" title=\"5.在浏览器中输入www.baidu.com后执行的全部过程\"></a>5.在浏览器中输入<a href=\"http://www.baidu.com后执行的全部过程/\">www.baidu.com后执行的全部过程</a></h2><ol>\n<li><strong>应用层：</strong>客户端浏览器通过DNS解析到<a href=\"http://www.baidu.com的ip地址220.181.27.48/\">www.baidu.com的IP地址220.181.27.48</a><ul>\n<li>通过这个IP地址找到客户端到服务器的路径</li>\n<li>客户端浏览器发起一个HTTP会话到220.161.27.48</li>\n<li>通过TCP进行封装数据包，输入到网络层。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong>DNS解析过程</strong></li>\n</ul>\n<img src=\"https://s2.loli.net/2023/04/04/lnDjAxvwUqudNyk.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n<ul>\n<li><strong>HTTP请求与响应</strong></li>\n</ul>\n<img src=\"https://s2.loli.net/2023/04/04/XdukvZ5ODB9LiWh.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n<ol start=\"2\">\n<li><p><strong>运输层：</strong>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口</p>\n<ul>\n<li>如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口</li>\n<li>然后使用IP层（网络层）的IP地址查找目的端</li>\n</ul>\n</li>\n<li><p><strong>网络层：</strong>通过查找路由表确定如何到达目的服务器</p>\n<ul>\n<li>期间可能经过多个路由器，这些都是由路由器来完成的工作，OSPF协议</li>\n</ul>\n</li>\n</ol>\n<img src=\"https://s2.loli.net/2023/04/04/t14UEpXTYRceCLW.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n<ol start=\"4\">\n<li><strong>链路层：</strong>客户端的链路层，通过链路层发送到路由器<ul>\n<li>通过邻居协议查找给定IP地址的MAC地址</li>\n<li>然后发送ARP请求查找目的地址</li>\n<li>如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了</li>\n<li>然后发送IP数据包到达服务器的地址。</li>\n</ul>\n</li>\n</ol>\n<img src=\"https://s2.loli.net/2023/04/04/73oANsLwERiVJnH.png\" alt=\"img\" style=\"zoom:67%;\" />  \n\n<hr>\n<h2 id=\"6-HTTP与HTTPS的区别\"><a href=\"#6-HTTP与HTTPS的区别\" class=\"headerlink\" title=\"6.HTTP与HTTPS的区别\"></a>6.HTTP与HTTPS的区别</h2><p>相关博文：<a href=\"https://blog.csdn.net/xiaoming100001/article/details/81109617\">https://blog.csdn.net/xiaoming100001/article/details/81109617</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</strong></p></blockquote>\n<h4 id=\"HTTPS和HTTP的区别主要如下：\"><a href=\"#HTTPS和HTTP的区别主要如下：\" class=\"headerlink\" title=\"HTTPS和HTTP的区别主要如下：\"></a>HTTPS和HTTP的区别主要如下：</h4><ol>\n<li><strong>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</strong></li>\n<li><strong>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</strong></li>\n<li><strong>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</strong></li>\n<li><strong>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</strong></li>\n</ol>\n<h4 id=\"HTTPS优缺点\"><a href=\"#HTTPS优缺点\" class=\"headerlink\" title=\"HTTPS优缺点\"></a>HTTPS优缺点</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>\n<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>\n<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>\n<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li>\n<li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li>\n<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li>\n<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li>\n<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>\n</ul>\n<hr>\n<h2 id=\"7-常见的HTTP方法\"><a href=\"#7-常见的HTTP方法\" class=\"headerlink\" title=\"7.常见的HTTP方法\"></a>7.常见的HTTP方法</h2><ul>\n<li><strong>GET：</strong> 从服务器获得资源</li>\n<li><strong>POST：</strong> 客户端向服务器提交资源</li>\n<li><strong>PUT：</strong> 修改服务器相关资源  (已经很少用)</li>\n<li><strong>DELETE：</strong> 删除服务器相关资源  (已经很少用)</li>\n</ul>\n<h3 id=\"GET方法与POST方法的区别-什么时候应该使用GET什么时候应该使用POST？\"><a href=\"#GET方法与POST方法的区别-什么时候应该使用GET什么时候应该使用POST？\" class=\"headerlink\" title=\"GET方法与POST方法的区别,什么时候应该使用GET什么时候应该使用POST？\"></a>GET方法与POST方法的区别,什么时候应该使用GET什么时候应该使用POST？</h3><ul>\n<li><strong>GET：</strong>一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</li>\n<li><strong>POST：</strong>一般用于修改服务器上的资源，对所发送的信息数量没有限制</li>\n<li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>小结：对于信息的获取一般使用get,在以下情况下最好使用post请求:</p></blockquote>\n<ol>\n<li>向服务器发送大量数据（因为post没有发送数据的数量限制） </li>\n<li>无法使用缓存文件（会更新服务器上的文件）</li>\n<li>发送包含未知字符的用户输入时(亲身经历过GET的坑,泪目)</li>\n</ol>\n<hr>\n<h2 id=\"8-HTTP1-0和HTTP1-1的区别\"><a href=\"#8-HTTP1-0和HTTP1-1的区别\" class=\"headerlink\" title=\"8.HTTP1.0和HTTP1.1的区别\"></a>8.<a href=\"https://www.cnblogs.com/gofighting/p/5421890.html\">HTTP1.0和HTTP1.1的区别</a></h2><h4 id=\"【1】缓存处理\"><a href=\"#【1】缓存处理\" class=\"headerlink\" title=\"【1】缓存处理\"></a>【1】缓存处理</h4><ul>\n<li><strong>HTTP1.0：</strong>主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准</li>\n<li><strong>HTTP1.1：</strong>则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>\n</ul>\n<h4 id=\"【2】带宽优化及网络连接的使用\"><a href=\"#【2】带宽优化及网络连接的使用\" class=\"headerlink\" title=\"【2】带宽优化及网络连接的使用\"></a>【2】带宽优化及网络连接的使用</h4><ul>\n<li><strong>HTTP1.0：</strong>存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能</li>\n<li><strong>HTTP1.1：</strong>在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n</ul>\n<h4 id=\"【3】错误通知的管理\"><a href=\"#【3】错误通知的管理\" class=\"headerlink\" title=\"【3】错误通知的管理\"></a>【3】错误通知的管理</h4><ul>\n<li>在HTTP1.1中新增了24个错误状态响应码<ul>\n<li>如409（Conflict）表示请求的资源与资源的当前状态发生冲突</li>\n<li>410（Gone）表示服务器上的某个资源被永久性的删除</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"【4】Host头处理\"><a href=\"#【4】Host头处理\" class=\"headerlink\" title=\"【4】Host头处理\"></a>【4】Host头处理</h4><p><strong>（但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址）</strong></p>\n<ul>\n<li><strong>HTTP1.0：</strong>认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）</li>\n<li><strong>HTTP1.1：</strong>请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）</li>\n</ul>\n<h4 id=\"【5】长连接\"><a href=\"#【5】长连接\" class=\"headerlink\" title=\"【5】长连接\"></a>【5】长连接</h4><ul>\n<li><strong>HTTP 1.1：</strong>支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理</li>\n<li>在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，</li>\n<li>+HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>\n</ul>\n","feature":true,"text":"相关博客 一、体系结构 OSI 七层模型 TCP&#x2F;IP 四层模型 TCP&#x2F;IP 五层模型 ​ 1.物理层 数据传输单位： 比特（bit） 作用： 激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性 设备： 中继器、集线器 2.数据链路层 数...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/tags/计算机网络.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">一、体系结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%89%A9%E7%90%86%E5%B1%82\"><span class=\"toc-text\">1.物理层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82\"><span class=\"toc-text\">2.数据链路层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%BD%91%E7%BB%9C%E5%B1%82\"><span class=\"toc-text\">3.网络层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%88Socket%EF%BC%89\"><span class=\"toc-text\">4.运输层（Socket）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%BC%9A%E8%AF%9D%E5%B1%82%E3%80%81%E8%A1%A8%E7%A4%BA%E5%B1%82\"><span class=\"toc-text\">5.会话层、表示层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E4%BC%9A%E8%AF%9D%E5%B1%82\"><span class=\"toc-text\">【1】会话层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E8%A1%A8%E7%A4%BA%E5%B1%82\"><span class=\"toc-text\">【2】表示层</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88%E6%9C%80%E9%9D%A0%E8%BF%91%E7%94%A8%E6%88%B7%E7%9A%84OSI%E5%B1%82%EF%BC%89\"><span class=\"toc-text\">6. 应用层（最靠近用户的OSI层）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81IP\"><span class=\"toc-text\">二、IP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-IP%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86\"><span class=\"toc-text\">1.IP地址划分</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86\"><span class=\"toc-text\">2.子网划分</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">三、协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-ARP-x2F-RARP\"><span class=\"toc-text\">1.ARP&#x2F;RARP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91ARP%E7%9A%84%EF%BC%88%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%EF%BC%89\"><span class=\"toc-text\">【1】ARP的（地址解析协议）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91RARP\"><span class=\"toc-text\">【2】RARP</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-TCP-x2F-UDP\"><span class=\"toc-text\">2.TCP&#x2F;UDP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91TCP%EF%BC%88%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%8CTransmission-Control-Protocl%EF%BC%89\"><span class=\"toc-text\">【1】TCP（传输控制协议，Transmission Control Protocl）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91UDP-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%8CUser-Datagram-Protocol%EF%BC%89\"><span class=\"toc-text\">【2】UDP(用户数据报协议，User Datagram Protocol）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91TCP-%E5%92%8C-UDP-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">【3】TCP 和 UDP 区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-x2F-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">3.TCP流量控制&#x2F;拥塞控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">【1】流量控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">【2】拥塞控制</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-ARQ%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">4.ARQ协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85ARQ%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">【1】停止等待ARQ协议</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">【2】连续ARQ协议</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-HTTP%EF%BC%88%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%89\"><span class=\"toc-text\">5.HTTP（超文本传输协议）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91HTTP-%E8%AF%B7%E6%B1%82-x2F-%E5%93%8D%E5%BA%94%E7%9A%84%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">【1】HTTP 请求&#x2F;响应的步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">HTTP常见状态码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4xx%EF%BC%9A-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF-%E8%AF%B7%E6%B1%82%E6%9C%89%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E6%88%96%E8%AF%B7%E6%B1%82%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4xx：(客户端请求错误) 请求有语法错误或请求无法实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5xx%EF%BC%9A%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF%EF%BC%89%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E5%B0%9D%E8%AF%95%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%97%B6%E5%8F%91%E7%94%9F%E5%86%85%E9%83%A8%E9%94%99%E8%AF%AF%E3%80%82-%E8%BF%99%E4%BA%9B%E9%94%99%E8%AF%AF%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E8%BA%AB%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E8%AF%B7%E6%B1%82%E5%87%BA%E9%94%99\"><span class=\"toc-text\">5xx：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81HTTP%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">常见HTTP首部字段</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-HTTPS\"><span class=\"toc-text\">6.HTTPS</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-SSL%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">7.SSL协议</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">四、面试题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">1.TCP协议如何保证可靠传输</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-TCP%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">2.TCP连接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81%E4%B8%80%E6%AC%A1%E7%A1%AE%E8%AE%A4%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">问：为什么TCP客户端最后还要发送一次确认呢？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-TCP%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">3.TCP连接释放</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E7%AD%89%E5%BE%852MSL%EF%BC%9F\"><span class=\"toc-text\">【1】问：为什么客户端最后还要等待2MSL？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%A1%AE%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">【2】问：为什么建立连接是三次握手，关闭连接确是四次挥手呢？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">【3】问：如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-DNS%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">4.DNS解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5www-baidu-com%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">5.在浏览器中输入www.baidu.com后执行的全部过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">6.HTTP与HTTPS的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%BB%E8%A6%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">HTTPS和HTTP的区别主要如下：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#HTTPS%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">HTTPS优缺点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">优点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">缺点</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">7.常见的HTTP方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GET%E6%96%B9%E6%B3%95%E4%B8%8EPOST%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8GET%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8POST%EF%BC%9F\"><span class=\"toc-text\">GET方法与POST方法的区别,什么时候应该使用GET什么时候应该使用POST？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-HTTP1-0%E5%92%8CHTTP1-1%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">8.HTTP1.0和HTTP1.1的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%901%E3%80%91%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86\"><span class=\"toc-text\">【1】缓存处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%902%E3%80%91%E5%B8%A6%E5%AE%BD%E4%BC%98%E5%8C%96%E5%8F%8A%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">【2】带宽优化及网络连接的使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%903%E3%80%91%E9%94%99%E8%AF%AF%E9%80%9A%E7%9F%A5%E7%9A%84%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">【3】错误通知的管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%904%E3%80%91Host%E5%A4%B4%E5%A4%84%E7%90%86\"><span class=\"toc-text\">【4】Host头处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%905%E3%80%91%E9%95%BF%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">【5】长连接</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"ARBIN","slug":"blog-author","avatar":"https://s2.loli.net/2023/04/04/dZv3NaCepc7X4MO.jpg","link":"/","description":"立志成为潮流研究生","socials":{"github":"https://github.com/Aidongo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"操作系统","uid":"8c6c59136f9c0c8c29b87ea646eed9d1","slug":"Computer Basis/操作系统知识点","date":"2023-04-04T01:04:00.000Z","updated":"2023-04-04T01:16:04.045Z","comments":true,"path":"api/articles/Computer Basis/操作系统知识点.json","keywords":null,"cover":"https://s2.loli.net/2023/04/04/xcKeEI3hwAW5JZN.jpg","text":"一、进程、线程、协程1.进程【1】定义 保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体 这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统 【2】特点 操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位 【3...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"操作系统","slug":"操作系统","count":1,"path":"api/tags/操作系统.json"}],"author":{"name":"ARBIN","slug":"blog-author","avatar":"https://s2.loli.net/2023/04/04/dZv3NaCepc7X4MO.jpg","link":"/","description":"立志成为潮流研究生","socials":{"github":"https://github.com/Aidongo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"SSql Language","uid":"1bf705b8c909d15201118f0311dec3fe","slug":"Kings/SSql Introduction","date":"2023-04-03T00:47:00.000Z","updated":"2023-04-03T03:15:35.138Z","comments":true,"path":"api/articles/Kings/SSql Introduction.json","keywords":null,"cover":"https://s2.loli.net/2023/04/03/vXmCDUSaoq1cGwt.png","text":"SSql Language: Simplified SQL and Data Analysis Language 📊Group Member Ruibin Zhu , Chenhui Liu Project OverviewSSql is a simplified SQL and...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"King's College London","slug":"King-s-College-London","count":1,"path":"api/categories/King-s-College-London.json"}],"tags":[{"name":"Coursework","slug":"Coursework","count":1,"path":"api/tags/Coursework.json"}],"author":{"name":"ARBIN","slug":"blog-author","avatar":"https://s2.loli.net/2023/04/04/dZv3NaCepc7X4MO.jpg","link":"/","description":"立志成为潮流研究生","socials":{"github":"https://github.com/Aidongo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}