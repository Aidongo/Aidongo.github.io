{"title":"LeetCode 数组","uid":"a82004346219b89210300085e2164ae5","slug":"面试攻略/数组","date":"2023-04-04T01:37:00.000Z","updated":"2023-04-04T01:46:00.260Z","comments":true,"path":"api/articles/面试攻略/数组.json","keywords":null,"cover":[],"content":"<h1 id=\"数组理论基础\"><a href=\"#数组理论基础\" class=\"headerlink\" title=\"数组理论基础\"></a>数组理论基础</h1><p><strong>概念：</strong>数组是存放在连续内存空间上的相同类型数据的集合</p>\n<p>字符数组例子：</p>\n<img src=\"https://s2.loli.net/2023/04/04/cRFnDe4iYVZd7qu.png\" alt=\"https://code-thinking.cdn.bcebos.com/pics/算法通关数组.png\" style=\"zoom: 80%;\" />\n\n<ul>\n<li>数组下标都是从0开始的。</li>\n<li>数组内存空间的地址是连续的</li>\n</ul>\n<p><strong>二维数组</strong></p>\n<img src=\"https://s2.loli.net/2023/04/04/SMAWz1bpnQvR4hC.png\" alt=\"Untitled\" style=\"zoom: 50%;\" />\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>Java的二维数组在内存中不是 <code>3*4</code> 的连续地址空间，而是四条连续的地址空间组成</strong></p></blockquote>\n<img src=\"https://s2.loli.net/2023/04/04/k5Bs7NlJH2iPGLW.png\" alt=\"Untitled\" style=\"zoom: 33%;\" />\n\n<h1 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a>704. 二分查找</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>\n<ul>\n<li><p>示例 1:</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9     \n输出: 4       \n解释: 9 出现在 nums 中并且下标为 4</code></pre>\n</li>\n<li><p>示例 2:</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2     \n输出: -1        \n解释: 2 不存在 nums 中因此返回 -1</code></pre></li>\n</ul>\n<p>提示：</p>\n<ul>\n<li>你可以假设 nums 中的所有元素是不重复的。</li>\n<li>n 将在 [1, 10000]之间。</li>\n<li>nums 的每个元素都将在 [-9999, 9999]之间。</li>\n</ul>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素。（二分法前提条件）</strong></p>\n<ul>\n<li>若存在重复元素，使用二分查找法返回的元素下标可能不是唯一的</li>\n<li>在二分查找的过程中，<strong>保持不变量（循环不变量规则）</strong><ul>\n<li>在while寻找中每一次边界的处理都要坚持根据区间的定义来操作</li>\n</ul>\n</li>\n</ul>\n<p>二分法：区间的定义一般为两种</p>\n<ol>\n<li><strong>左闭右闭，</strong><code>[left, right]</code></li>\n<li><strong>左闭右开，</strong><code>[left, right)</code></li>\n</ol>\n<h3 id=\"✏️-写法一（左闭右闭）\"><a href=\"#✏️-写法一（左闭右闭）\" class=\"headerlink\" title=\"✏️ 写法一（左闭右闭）\"></a>✏️ <strong>写法一（左闭右闭）</strong></h3><p>定义 target 是在一个在左闭右闭的区间里，即 **<code>[left, right]</code>**，因此有如下两点：</p>\n<ul>\n<li><strong>while (left &lt;&#x3D; right) ：使用 &lt;&#x3D;</strong><ul>\n<li>因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>\n</ul>\n</li>\n<li><strong>if (nums[middle] &gt; target)</strong><ul>\n<li>right 要赋值为 (middle - 1)，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 (middle - 1)</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>例如在数组：1,2,3,4,7,9,10中查找元素2：</strong></p></blockquote>\n<img src=\"https://s2.loli.net/2023/04/04/zRY1PaOvncqKH8k.png\" alt=\"Untitled\" style=\"zoom:50%;\" />\n\n\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int left &#x3D; 0;\n        int right &#x3D; nums.length - 1;           &#x2F;&#x2F; 定义target在左闭右闭的区间里，[left, right]\n        &#x2F;&#x2F; 判断是否不存在\n        if(target &lt; nums[left] || target &gt; nums[right])\n            return -1;\n        while (left &lt;&#x3D; right) &#123;                &#x2F;&#x2F; 当left&#x3D;&#x3D;right，区间[left, right]依然有效，所以用 &lt;&#x3D;\n            int mid &#x3D; (right + left) &#x2F; 2;\n            if(nums[mid] &#x3D;&#x3D; target)\n                return mid;                   &#x2F;&#x2F; 数组中找到目标值，直接返回下标\n            else if (nums[mid] &lt; target)      \n                left &#x3D; mid + 1;               &#x2F;&#x2F; target 在右区间，所以[middle + 1, right]\n            else if (nums[mid] &gt; target)\n                right &#x3D; mid - 1;              &#x2F;&#x2F; target 在左区间，所以[left, middle - 1]\n        &#125;\n\t\t\t\t&#x2F;&#x2F; 未找到目标值\n        return -1;\n    &#125;\n&#125;</code></pre>\n\n<hr>\n<h3 id=\"✏️-写法二：左闭右开\"><a href=\"#✏️-写法二：左闭右开\" class=\"headerlink\" title=\"✏️ 写法二：左闭右开\"></a>✏️ <strong>写法二：左闭右开</strong></h3></aside>\n\n<p>定义 target 是在一个在左闭右开的区间里：<code>[left, right)</code></p>\n<ul>\n<li><strong>while (left &lt; right) ：使用 &lt;</strong><ul>\n<li>因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的</li>\n</ul>\n</li>\n<li><strong>if (nums[middle] &gt; target)</strong><ul>\n<li>right 更新为 middle：因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，</li>\n<li>即：下一个查询区间不会去比较nums[middle]</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>例如在数组：1,2,3,4,7,9,10中查找元素2：</strong></p></blockquote>\n<img src=\"https://s2.loli.net/2023/04/04/OyCH76ETmZnfcu3.png\" alt=\"Untitled\" style=\"zoom: 50%;\" />\n\n\n\n<p><strong>代码示例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int left &#x3D; 0;\n        int rifht &#x3D; nums.length;        &#x2F;&#x2F; 定义target在左闭右开的区间里，即：[left, right)\n        while(left &lt; rifht)&#123;            &#x2F;&#x2F; 因为left &#x3D;&#x3D; right的时候，在[left, right)是无效的空间，所以使用 &lt;\n            int mid &#x3D; (left + rifht) &#x2F; 2;\n            if(target &#x3D;&#x3D; nums[mid])     &#x2F;&#x2F; 数组中找到目标值，直接返回下标\n                return mid;\n            else if(target &lt; nums[mid])\n                rifht &#x3D; mid;            &#x2F;&#x2F; target 在左区间，在[left, middle)中\n            else if(target &gt; nums[mid])\n                left &#x3D; mid + 1;         &#x2F;&#x2F; target 在右区间，在[middle + 1, right)中\n        &#125;\n        &#x2F;&#x2F; 未找到目标值\n        return -1;\n    &#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"027-移除元素\"><a href=\"#027-移除元素\" class=\"headerlink\" title=\"027. 移除元素\"></a>027. 移除元素</h1><h2 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个数组 <code>nums</code> **和一个值 <code>val</code>，你需要 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong> 移除所有数值等于 <code>val</code> **的元素，并返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a> 修改输入数组</strong>。</p>\n<p>元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。</p>\n<ul>\n<li><p>示例 1：</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3\n输出：2, nums &#x3D; [2,2]\n解释：函数应该返回新的长度2, 并且 nums中的前两个元素均为2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</code></pre>\n</li>\n<li><p>示例 2：</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2\n输出：5, nums &#x3D; [0,1,4,0,3]\n解释：函数应该返回新的长度5, 并且 nums 中的前五个元素为0,1,3,0,4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre></li>\n</ul>\n<p>提示：</p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n<h2 id=\"思路（快慢指针）\"><a href=\"#思路（快慢指针）\" class=\"headerlink\" title=\"思路（快慢指针）\"></a>思路（快慢指针）</h2><p><strong>双指针：</strong> 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p>\n<p><strong>定义快慢指针</strong></p>\n<ul>\n<li>快指针：寻找新数组的元素</li>\n<li>慢指针：新数组下标的位置</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int removeElement(int[] nums, int val) &#123;\n        &#x2F;&#x2F; 快慢指针\n        int slowIndex &#x3D; 0;\n        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.length; fastIndex++)&#123;\n            if(nums[fastIndex] !&#x3D; val)&#123;\n                nums[slowIndex] &#x3D; nums[fastIndex];\n                slowIndex ++;\n            &#125;\n        &#125;\n        return slowIndex;\n    &#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977. 有序数组的平方\"></a>977. 有序数组的平方</h1><h2 id=\"题目-2\"><a href=\"#题目-2\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>\n<ul>\n<li><p>示例 1：</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums &#x3D; [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]</code></pre>\n</li>\n<li><p>示例 2：</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums &#x3D; [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n</code></pre></li>\n</ul>\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>\n</ul>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>\n<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>\n<p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p>\n<p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置：</p>\n<ul>\n<li><code>A[i] * A[i] &lt; A[j] * A[j]</code> ⇒ <code>result[k--] = A[j] * A[j];</code></li>\n<li><code>A[i] * A[i] &gt;= A[j] * A[j]</code> ⇒ <code>result[k--] = A[i] * A[i];</code></li>\n</ul>\n<p><strong>代码示例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int[] sortedSquares(int[] nums) &#123;\n        int left &#x3D; 0;\n        int right &#x3D; nums.length - 1;\n        int[] result &#x3D; new int[nums.length];\n        int index &#x3D; result.length - 1;\n        while(left &lt;&#x3D; right)&#123;\n            if(nums[left] * nums[left] &gt; nums[right] * nums[right])&#123;\n                &#x2F;&#x2F; 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置\n                result[index--] &#x3D; nums[left] * nums[left];\n                ++left;\n            &#125; else &#123;\n                result[index--] &#x3D; nums[right] * nums[right];\n                --right;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209. 长度最小的子数组\"></a>209. 长度最小的子数组</h1><p>给定一个含有 <code>n</code> ****个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>\n<p>找出该数组中满足其和 ****<code>≥ target</code> *<em><strong>的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度</strong>。</em>*如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\n<ul>\n<li><p>示例 1：</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组[4,3] 是该条件下的长度最小的子数组。\n</code></pre>\n</li>\n<li><p>示例 2：</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：target &#x3D; 4, nums &#x3D; [1,4,4]\n输出：1\n</code></pre>\n</li>\n<li><p>示例 3：</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]\n输出：0\n</code></pre></li>\n</ul>\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= target &lt;= 109</code></li>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"思路（滑动窗口）\"><a href=\"#思路（滑动窗口）\" class=\"headerlink\" title=\"思路（滑动窗口）\"></a>思路（滑动窗口）</h2><p>在本题中实现滑动窗口，主要确定如下三点：</p>\n<ul>\n<li>窗口内是什么？<ul>\n<li>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</li>\n</ul>\n</li>\n<li>如何移动窗口的起始位置？<ul>\n<li>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</li>\n</ul>\n</li>\n<li>如何移动窗口的结束位置？<ul>\n<li>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>举例，s&#x3D;7， 数组是 2，3，1，2，4，3，来看一下查找的过程</strong></p></blockquote>\n<img src=\"https://s2.loli.net/2023/04/04/8bEj2friNDRhYHV.gif\" alt=\"https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif\" style=\"zoom:67%;\" />\n\n<p><strong>代码示例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int minSubArrayLen(int target, int[] nums) &#123;\n        int result &#x3D; Integer.MAX_VALUE;\n        int i &#x3D; 0; &#x2F;&#x2F; 滑动窗口的起始位置\n        int sum &#x3D; 0; &#x2F;&#x2F; 滑动窗口数值总和\n        int subLength &#x3D; 0; &#x2F;&#x2F; 滑动窗口的长度\n        for (int j &#x3D; 0; j &lt; nums.length; j++)&#123;\n            sum +&#x3D; nums[j];\n            &#x2F;&#x2F; 当终止位置j向后移动至窗口内数值总和 &gt;&#x3D; target时\n            while (sum &gt;&#x3D; target)&#123;          &#x2F;&#x2F; 使用while，移动起始位置i，并判断子序列是否符合条件\n                subLength &#x3D; (j - i + 1);    &#x2F;&#x2F; 获取子序列长度\n                result &#x3D; result &lt; subLength ? result : subLength;\n                sum -&#x3D; nums[i++];   &#x2F;&#x2F; 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result &#x3D;&#x3D; Integer.MAX_VALUE ? 0 : result;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><strong>时间复杂度：O(n)</strong><ul>\n<li>主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</li>\n</ul>\n</li>\n<li><strong>空间复杂度：O(1)</strong></li>\n</ul>\n<hr>\n<h1 id=\"59-螺旋矩阵II\"><a href=\"#59-螺旋矩阵II\" class=\"headerlink\" title=\"59.螺旋矩阵II\"></a>59.螺旋矩阵II</h1><h2 id=\"题目-3\"><a href=\"#题目-3\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 $<code>n^2</code>$所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>\n<ul>\n<li><p>示例 1：</p>\n<p>  <img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" alt=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\"></p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n</code></pre>\n</li>\n<li><p>示例 2：</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：[[1]]\n</code></pre></li>\n</ul>\n<p>提示<strong>：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>模拟顺时针画矩阵的过程（坚持循环不变量原则）:</p>\n<ul>\n<li>填充上行从左到右</li>\n<li>填充右列从上到下</li>\n<li>填充下行从右到左</li>\n<li>填充左列从下到上</li>\n</ul>\n<p><strong>左闭右开原则：</strong></p>\n<img src=\"https://s2.loli.net/2023/04/04/i7zdf3mAKaXylk9.png\" alt=\"Untitled\" style=\"zoom: 33%;\" />\n\n<p><strong>代码示例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int[][] generateMatrix(int n) &#123;\n        int[][] res &#x3D; new int[n][n];\n        int start &#x3D; 0;&#x2F;&#x2F;定义每个圈的起始位置\n        int loop &#x3D; 0;       &#x2F;&#x2F; 每一个圈循环的次数\n        int count &#x3D; 1;      &#x2F;&#x2F; 定义填充数字，从1开始\n        int i,j;\n        while(loop++ &lt; n&#x2F;2)&#123;    &#x2F;&#x2F; 判断边界后，loop从1开始, loop也能作为控制的遍历长度\n\n            &#x2F;&#x2F; 下面开始的四个for就是模拟转了一圈\n            &#x2F;&#x2F; 模拟填充上行从左到右(左闭右开)\n            for(j &#x3D; start; j &lt; n - loop; j++)\n                res[start][j] &#x3D; count++;\n\n            &#x2F;&#x2F; 模拟填充右列从上到下(左闭右开)\n            for(i &#x3D; start; i &lt; n - loop; i++)\n                res[i][j] &#x3D; count++;\n\n            &#x2F;&#x2F; 模拟填充下行从右到左(左闭右开)\n            for(; j &gt;&#x3D; loop; j--)\n                res[i][j] &#x3D; count++;\n\n            &#x2F;&#x2F; 模拟填充左列从下到上(左闭右开)\n            for(; i &gt;&#x3D; loop; i--)\n                res[i][j] &#x3D; count++;\n\n            &#x2F;&#x2F; 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)\n            start++;\n        &#125;\n\n        &#x2F;&#x2F; 如果n为奇数的话，需要单独给矩阵最中间的位置赋值\n        if (n % 2 &#x3D;&#x3D; 1)\n            res[start][start] &#x3D; count;\n\n        return res;\n    &#125;\n&#125;</code></pre>","feature":true,"text":"数组理论基础概念：数组是存放在连续内存空间上的相同类型数据的集合 字符数组例子： 数组下标都是从0开始的。 数组内存空间的地址是连续的 二维数组 Java的二维数组在内存中不是 3*4 的连续地址空间，而是四条连续的地址空间组成 704. 二分查找题目给定一个 n 个元素有序的（...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"LeetCode","slug":"LeetCode","count":1,"path":"api/categories/LeetCode.json"}],"tags":[{"name":"数组","slug":"数组","count":1,"path":"api/tags/数组.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">数组理论基础</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">704. 二分查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%9C%8F%EF%B8%8F-%E5%86%99%E6%B3%95%E4%B8%80%EF%BC%88%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD%EF%BC%89\"><span class=\"toc-text\">✏️ 写法一（左闭右闭）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%9C%8F%EF%B8%8F-%E5%86%99%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80\"><span class=\"toc-text\">✏️ 写法二：左闭右开</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">027. 移除元素</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE-1\"><span class=\"toc-text\">题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89\"><span class=\"toc-text\">思路（快慢指针）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9\"><span class=\"toc-text\">977. 有序数组的平方</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE-2\"><span class=\"toc-text\">题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-1\"><span class=\"toc-text\">思路</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">209. 长度最小的子数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89\"><span class=\"toc-text\">思路（滑动窗口）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II\"><span class=\"toc-text\">59.螺旋矩阵II</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE-3\"><span class=\"toc-text\">题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-2\"><span class=\"toc-text\">思路</span></a></li></ol></li></ol>","author":{"name":"ARBIN","slug":"arbin","avatar":"https://s2.loli.net/2023/04/04/dZv3NaCepc7X4MO.jpg","link":"/","description":"立志成为潮流研究生","socials":{"github":"https://github.com/Aidongo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Notion":{"icon":"/svg/notion_black_logo_icon_147102.png","link":"https://arbin29.notion.site/ARBIN-HomePage-641b7c55779f4920869022cad678e8a5"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"操作系统","uid":"8c6c59136f9c0c8c29b87ea646eed9d1","slug":"Computer Basis/操作系统知识点","date":"2023-04-04T01:04:00.000Z","updated":"2023-04-04T01:16:04.045Z","comments":true,"path":"api/articles/Computer Basis/操作系统知识点.json","keywords":null,"cover":"https://s2.loli.net/2023/04/04/xcKeEI3hwAW5JZN.jpg","text":"一、进程、线程、协程1.进程【1】定义 保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体 这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统 【2】特点 操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位 【3...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"操作系统","slug":"操作系统","count":1,"path":"api/tags/操作系统.json"}],"author":{"name":"ARBIN","slug":"arbin","avatar":"https://s2.loli.net/2023/04/04/dZv3NaCepc7X4MO.jpg","link":"/","description":"立志成为潮流研究生","socials":{"github":"https://github.com/Aidongo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Notion":{"icon":"/svg/notion_black_logo_icon_147102.png","link":"https://arbin29.notion.site/ARBIN-HomePage-641b7c55779f4920869022cad678e8a5"}}}},"feature":true}}